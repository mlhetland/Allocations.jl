<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Allocations.jl · Allocations</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Allocations</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Allocations.jl</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Basic-use"><span>Basic use</span></a></li><li><a class="tocitem" href="#Solver-configuration"><span>Solver configuration</span></a></li></ul></li><li><a class="tocitem" href="reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Allocations.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Allocations.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mlhetland/Allocations.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Allocations.jl"><a class="docs-heading-anchor" href="#Allocations.jl">Allocations.jl</a><a id="Allocations.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Allocations.jl" title="Permalink"></a></h1><p>The Allocations package deals with the fair allocation of indivisible items to a set of agents. An instance of this problem consists of:</p><ul><li>A set <span>$N$</span> of <span>$n$</span> <em>agents</em> and a set <span>$M$</span> of <span>$m$</span> <em>items</em>;</li><li>One <em>valuation function</em> <span>$v_i:2^M\to\R$</span> for each agent <span>$i\in N$</span>;</li></ul><p>For simplicity, we may simply let <span>$N=\{1,\dots,n\}$</span> and <span>$M=\{1,\dots,m\}$</span>.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p><p>The goal is to find an <em>allocation</em> <span>$A=(A_1,\dots,A_n)$</span>, which gives a <em>bundle</em> <span>$A_i\subseteq M$</span> to each agent, and which satisfies certain fairness criteria. The allocation is usually required to form a partition of <span>$M$</span>, though in some scenarios, one may deviate from this.</p><p>In <code>Allocations.jl</code>, an instance is represented by the <em>valuation profile</em> <span>$V=\{v_i:i\in N\}$</span>, in the form of a <code>Profile</code> object. Given a profile <code>V</code>, the various parts of the instance may be accessed as follows:</p><ul><li><code>items(V)</code>: The item set <span>$N$</span>, as an iterable;</li><li><code>agents(V)</code>: The agent set <span>$M$</span>, as an iterable;</li><li><code>value(V, i, S)</code>: The value agent <span>$i$</span> assigns to the set <span>$S\subseteq M$</span>, i.e., <span>$v_i(S)$</span>.</li></ul><p><code>S</code> may be any iterable. If it a single item (i.e., <code>Int</code>) <code>g</code>, it is interpreted as a singleton, <code>[g]</code> (though usually handled more efficiently). The number of agents and items, respectively, are found using <code>na(V)</code> and <code>ni(V)</code></p><p>In addition to this basic setting, instances may be constrained, by supplying some <em>constraint object</em>, describing which bundles are feasible. For example, if one is looking for bundles that are <em>connected</em> in some sense, the constraint object will typically be a graph that defines the connectivity relation, etc.</p><p>Allocations are represented by <code>Allocation</code> objects. Given an allocation <code>A</code>, the bundle of agent <code>i</code> is found using <code>bundle(A, i)</code>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>For more on this topic, see, e.g., the <a href="https://en.wikipedia.org/wiki/Fair_item_allocation">Wikipedia entry on fair item allocation</a>, or the surveys by <a href="https://arxiv.org/abs/2208.08782">Amanatidis et al.</a> and <a href="https://doi.org/10.1145/3505156.3505162">Suksompong</a>, on the unconstrained and constrained versions of the problem, respectively.</p></div></div><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>To install the package, you can simply import it in the <a href="https://docs.julialang.org/en/v1/stdlib/REPL/">Julia REPL</a>:</p><pre><code class="language-julia-repl hljs">julia&gt; using Allocations</code></pre><p>Press enter at the resulting prompt to install both the package and its dependencies.</p><p>To install a more recent version than the released one, you can use the package manager directly. In the Julia REPL, press <code>]</code> to enter the <code>Pkg</code> REPL, and then add the package directly from the source:</p><pre><code class="language-julia-repl hljs">pkg&gt; add https://github.com/mlhetland/Allocations.jl</code></pre><p>You can then import the module as before.</p><h2 id="Basic-use"><a class="docs-heading-anchor" href="#Basic-use">Basic use</a><a id="Basic-use-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-use" title="Permalink"></a></h2><p>To specify an allocation problem instance, create a valuation profile:</p><pre><code class="language-julia-repl hljs">julia&gt; V = Profile([1 2 3; 2 3 1])
Additive{Matrix{Int64}} with 2 agents and 3 items:
 1  2  3
 2  3  1</code></pre><p><code>Profile</code> is an abstract class, and <code>Profile(X::Matrix)</code> is an alias for <code>Additive(X)</code>. Once you have a valuation profile, you can use an allocation function (ones called <code>alloc_...</code>), e.g., for finding a maximum Nash welfare (MNW) allocation:</p><pre><code class="language-julia-repl hljs">julia&gt; res = alloc_mnw(V);</code></pre><p>Note that the first time you call an allocation function, it may take some time to finish, because there&#39;s quite a lot of compilation going on behind the scenes. From then on, in the same REPL session, there will be much less overhead.</p><p>These functions take a <code>Profile</code> as input and return a named tuple with the field <code>alloc</code> referring to an <code>Allocation</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; A = res.alloc
Allocation with 2 agents and 3 items:
  1 =&gt; {3}
  2 =&gt; {1, 2}</code></pre><p>The bundle of each agent is available through the <code>bundle</code> function:</p><pre><code class="language-julia-repl hljs">julia&gt; bundle(A, 2)
Set{Int64} with 2 elements:
  2
  1</code></pre><p>Bundles should not be modified directly, as the <code>Allocation</code> also maintains an inverse mapping, from items to agents. Rather, use the <code>give!</code> and <code>deny!</code> functions.</p><p>Some allocation functions may produce other results as well, such as properties of the allocation that are naturally computed as part of the allocation process. For the MNW case, the objective value (the Nash welfare, which is being maximized) is available as <code>mnw</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; res.mnw
15.0</code></pre><p>The allocation functions also permit a matrix argument as a shortcut, implicitly creating an <code>Additive</code>. For example, you can find a maximin share (MMS) allocation as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; alloc_mms([1 1 2 3; 2 1 2 3]).alloc
Allocation with 2 agents and 4 items:
  1 =&gt; {2, 3}
  2 =&gt; {1, 4}</code></pre><h2 id="Solver-configuration"><a class="docs-heading-anchor" href="#Solver-configuration">Solver configuration</a><a id="Solver-configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-configuration" title="Permalink"></a></h2><p>Several allocation functions use mixed-integer linear programming via <a href="https://jump.dev">JuMP</a>. Depending on the choice of MIP solver, solving even moderately-sized instances may take a significant amount of time. Choosing a different solver (from the default <code>HiGHS.Optimizer</code>) may speed things up considerably. For example, with the appropriate license, one could use use <a href="https://www.gurobi.com">Gurobi</a> as follows:<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></p><pre><code class="language-julia hljs">Allocations.conf.MIP_SOLVER = Gurobi.Optimizer</code></pre><p>It is also possible to supply the <code>Optimizer</code> (or other optimizer factories, e.g., constructed using <code>optimizer_with_attributes</code>) as the <code>solver</code> keyword argument to the relevant allocation functions.</p><p>Normally, the MIP solvers will print out quite a lot of information about what they&#39;re doing. If you&#39;re not interested in this output, you can generally turn it off using some solver-specific flag, supplied to <code>optimizer_with_attributes</code>.<sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup> This is also where you&#39;d supply other parameters, e.g., indicating time limits, acceptable inaccuracies, etc. For example:<sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup></p><pre><code class="language-julia hljs">Allocations.conf.MIP_SOLVER = optimizer_with_attributes(
    Gurobi.Optimizer,
    &quot;LogToConsole&quot; =&gt; 0,     # No console output
    &quot;TimeLimit&quot; =&gt; 60,       # Finish within 60 seconds
    &quot;MipGap&quot; =&gt; 0.05,        # Permit 5% suboptimality
)</code></pre><p>If you&#39;re unable to get rid of the output using solver parameters, a simple solution is to just silence all output while allocating:</p><pre><code class="language-julia-repl hljs">julia&gt; redirect_stdout(devnull) do
           alloc_mnw(V)
       end</code></pre><p>If that doesn&#39;t do the trick, you could add <code>redirect_stderr</code> as well.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>The latter is less common, presumably because the two sets then intersect. An alternative is to let <span>$M$</span> be a set of opaque objects <span>$g_j$</span>, for <span>$j=1\dots m$</span>.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>If you&#39;re a student or a researcher, Gurobi is <a href="https://www.gurobi.com/academia">available for free under an academic license</a>.</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>There is also the <code>JuMP.set_silent</code> function, but it requires access to the MIP model.</li><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a>See the <a href="https://www.gurobi.com/documentation/10.0/refman/parameters.html">Gurobi</a> manual for explanations.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 16 March 2023 09:19">Thursday 16 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
