<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Allocations.jl · Allocations</title><meta name="title" content="Allocations.jl · Allocations"/><meta property="og:title" content="Allocations.jl · Allocations"/><meta property="twitter:title" content="Allocations.jl · Allocations"/><meta name="description" content="Documentation for Allocations."/><meta property="og:description" content="Documentation for Allocations."/><meta property="twitter:description" content="Documentation for Allocations."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Allocations</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Allocations.jl</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Basic-use"><span>Basic use</span></a></li><li><a class="tocitem" href="#Constraints"><span>Constraints</span></a></li><li><a class="tocitem" href="#generalized"><span>Generalized allocations</span></a></li><li><a class="tocitem" href="#Solver-configuration"><span>Solver configuration</span></a></li></ul></li><li><a class="tocitem" href="reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Allocations.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Allocations.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mlhetland/Allocations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mlhetland/Allocations.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Allocations.jl"><a class="docs-heading-anchor" href="#Allocations.jl">Allocations.jl</a><a id="Allocations.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Allocations.jl" title="Permalink"></a></h1><p>The Allocations package deals with the fair allocation of indivisible items to a set of agents. An instance of this problem consists of:</p><ul><li>A set <span>$N$</span> of <span>$n$</span> <em>agents</em> and a set <span>$M$</span> of <span>$m$</span> <em>items</em>;</li><li>One <em>valuation function</em> <span>$v_i:2^M\to\R$</span> for each agent <span>$i\in N$</span>;</li></ul><p>For simplicity, we may simply let <span>$N=\{1,\dots,n\}$</span> and <span>$M=\{1,\dots,m\}$</span>.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p><p>The goal is to find an <em>allocation</em> <span>$A=(A_1,\dots,A_n)$</span>, which gives a <em>bundle</em> <span>$A_i\subseteq M$</span> to each agent, and which satisfies certain fairness criteria. The allocation is usually required to form a partition of <span>$M$</span>, though in some scenarios, one may deviate from this.</p><p>In <code>Allocations.jl</code>, an instance is represented by the <em>valuation profile</em> <span>$V=\{v_i:i\in N\}$</span>, in the form of a <code>Profile</code> object. Given a profile <code>V</code>, the various parts of the instance may be accessed as follows:</p><ul><li><code>items(V)</code>: The item set <span>$N$</span>, as an iterable;</li><li><code>agents(V)</code>: The agent set <span>$M$</span>, as an iterable;</li><li><code>value(V, i, S)</code>: The value agent <span>$i$</span> assigns to the set <span>$S\subseteq M$</span>, i.e., <span>$v_i(S)$</span>.</li></ul><p><code>S</code> may be any iterable. If it a single item (i.e., <code>Int</code>) <code>g</code>, it is interpreted as a singleton, <code>[g]</code> (though usually handled more efficiently). The number of agents and items, respectively, are found using <code>na(V)</code> and <code>ni(V)</code></p><p>In addition to this basic setting, instances may be constrained, by supplying some <em>constraint object</em>, describing which bundles are feasible. For example, if one is looking for bundles that are <em>connected</em> in some sense, the constraint object will typically be a graph that defines the connectivity relation, etc.</p><p>Allocations are represented by <code>Allocation</code> objects. Given an allocation <code>A</code>, the bundle of agent <code>i</code> is found using <code>bundle(A, i)</code>.</p><div class="admonition is-success" id="Tip-a7a3cbf79cdb4113"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-a7a3cbf79cdb4113" title="Permalink"></a></header><div class="admonition-body"><p>For more on this topic, see, e.g., the <a href="https://en.wikipedia.org/wiki/Fair_item_allocation">Wikipedia entry on fair item allocation</a>, or the surveys by <a href="https://arxiv.org/abs/2208.08782">Amanatidis et al.</a> and <a href="https://doi.org/10.1145/3505156.3505162">Suksompong</a>, on the unconstrained and constrained versions of the problem, respectively.</p></div></div><p>In classical <a href="https://en.wikipedia.org/wiki/Fair_division">fair division</a>, the resources being allocated are assumed to be <em>divisible</em>, and in some recent work, a mixture of divisible and indivisible resources is permitted. The Allocations package does not support this directly, but you can approximately represent a divisible resource as a set of indivisible ones. For example, you could follow the strategy used by <a href="http://www.spliddit.org">Spliddit</a>, and divide such resources into 100 pieces, giving each piece 1% of the original value.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>To install the package, you can simply import it in the <a href="https://docs.julialang.org/en/v1/stdlib/REPL/">Julia REPL</a>:</p><pre><code class="language-julia-repl hljs">julia&gt; using Allocations</code></pre><p>Press enter at the resulting prompt to install both the package and its dependencies.</p><p>To install a more recent version than the released one, you can use the package manager directly. In the Julia REPL, press <code>]</code> to enter the <code>Pkg</code> REPL, and then add the package directly from the source:</p><pre><code class="language-julia-repl hljs">pkg&gt; add https://github.com/mlhetland/Allocations.jl</code></pre><p>You can then import the module as before.</p><h2 id="Basic-use"><a class="docs-heading-anchor" href="#Basic-use">Basic use</a><a id="Basic-use-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-use" title="Permalink"></a></h2><p>To specify an allocation problem instance, create a valuation profile:</p><pre><code class="language-julia-repl hljs">julia&gt; V = Profile([1 2 3; 2 3 1])
Additive{Matrix{Int64}} with 2 agents and 3 items:
 1  2  3
 2  3  1</code></pre><p><code>Profile</code> is an abstract class, and <code>Profile(X::Matrix)</code> is an alias for <code>Additive(X)</code>. Once you have a valuation profile, you can use an allocation function (ones called <code>alloc_...</code>), e.g., for finding a maximum Nash welfare (MNW) allocation:</p><pre><code class="language-julia-repl hljs">julia&gt; res = alloc_mnw(V);</code></pre><p>Note that the first time you call an allocation function, it may take some time to finish, because there&#39;s quite a lot of compilation going on behind the scenes. From then on, in the same REPL session, there will be much less overhead.</p><p>These functions take a <code>Profile</code> as input and return a named tuple with the field <code>alloc</code> referring to an <code>Allocation</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; A = res.alloc
Allocation with 2 agents and 3 items:
  1 =&gt; {3}
  2 =&gt; {1, 2}</code></pre><p>The bundle of each agent is available through the <code>bundle</code> function:</p><pre><code class="language-julia-repl hljs">julia&gt; bundle(A, 2)
Set{Int64} with 2 elements:
  2
  1</code></pre><p>Bundles should not be modified directly, as the <code>Allocation</code> also maintains an inverse mapping, from items to agents. Rather, use the <code>give!</code> and <code>deny!</code> functions.</p><p>Some allocation functions may produce other results as well, such as properties of the allocation that are naturally computed as part of the allocation process. For the MNW case, the objective value (the Nash welfare, which is being maximized) is available as <code>mnw</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; res.mnw
15.0</code></pre><p>The allocation functions also permit a matrix argument as a shortcut, implicitly creating an <code>Additive</code>. For example, you can find a maximin share (MMS) allocation as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; alloc_mms([1 1 2 3; 2 1 2 3]).alloc
Allocation with 2 agents and 4 items:
  1 =&gt; {2, 3}
  2 =&gt; {1, 4}</code></pre><h2 id="Constraints"><a class="docs-heading-anchor" href="#Constraints">Constraints</a><a id="Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints" title="Permalink"></a></h2><p>In <em>constrained</em> fair allocation, extra criteria determine which allocations are allowed, or <em>feasible</em>. Such constraints could, in principle, designate any class of allocations as feasible, but the most common scenario is that the constraints is only concerned with <em>bundles</em>, i.e., which bundles are feasible, individually.</p><div class="admonition is-info" id="Note-5e621a789fc8a8a7"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-5e621a789fc8a8a7" title="Permalink"></a></header><div class="admonition-body"><p>One example of a different kind of constraint is that of <a href="https://doi.org/10.1016/j.tcs.2018.05.018">Gourvès and Monnot</a>, who permit <a href="#generalized">partial allocations</a>, but require the set of allocated items to be a basis of a given matroid.</p></div></div><p>In the Allocations package, constrained instances are represented by a valuation <a href="reference/#Allocations.Profile"><code>Profile</code></a> along with a single <a href="reference/#Allocations.Constraint"><code>Constraint</code></a> object. (If one wishes to combine constraints, this can be achieved using the <a href="#Constraints"><code>Constraints</code></a> type.) For example, one might use a graph to indicate items that are in conflict, and cannot be allocated to the same agent:</p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; V = Additive([1 1 0; 0 0 2])
Additive{Matrix{Int64}} with 2 agents and 3 items:
 1  1  0
 0  0  2

julia&gt; G = path_graph(3)
{3, 2} undirected simple Int64 graph

julia&gt; alloc_mnw(V, Conflicts(G)).alloc
Allocation with 2 agents and 3 items:
  1 =&gt; {2}
  2 =&gt; {1, 3}</code></pre><p>In this example, agent <code>1</code> wants the first two items, while agent <code>2</code> want the third. Allocating accordingly would provide a perfectly fair distribution, with identical utility for both agents. However, our conflict graph—a path of length 3—tells us that no agent can have both items <code>1</code> and <code>2</code> (nor both <code>2</code> and <code>3</code>). Our only choice, then (to avoid a Nash welfare of zero) is for the second agent to get the first and third items.</p><p>For an overview of several types of constraints (<a href="reference/#types">some of which</a> are implemented by the Allocations library), see, e.g., the survey by <a href="https://doi.org/10.1145/3505156.3505162">Suksompong</a>.</p><h3 id="Symmetry"><a class="docs-heading-anchor" href="#Symmetry">Symmetry</a><a id="Symmetry-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetry" title="Permalink"></a></h3><p>We call a constraint <em>symmetric in the agents</em> (or simply <em>symmetric</em>) if the set of feasible bundles is the same for all agents. This is the most common case, though there are exceptions. For example, <a href="https://ojs.aaai.org/index.php/AAAI/article/view/16670">Dror et al.</a> let agents have different matroid constraints, and with so-called <a href="https://arxiv.org/abs/2012.03766"><em>budget constraints</em></a>, the agents may have different budgets. The <a href="reference/#Allocations.Permitted"><code>Permitted</code></a>, <a href="reference/#Allocations.Forbidden"><code>Forbidden</code></a> and <a href="reference/#Allocations.Required"><code>Required</code></a> constraints are also asymmetric, in general.</p><p>For many purposes, symmetry makes no difference. One important exception is finding MMS-allocations. For symmetric constraints (and in the unconstrained case), an agent&#39;s <em>maximin share</em> (MMS) is the greatest value she can get if she gets the worst bundle in a feasible partition of the items, and an MMS allocation is one where each agent gets her MMS.</p><p>If the constraint is asymmetric, however, this definition of MMS might not make sense. The idea is that the agent partitions the items, and then gets to choose last—i.e., gets the worst bundle, according to her. However, different constraints apply to the different bundles, she could find a partition where she isn&#39;t <em>permitted</em> the worst bundle, for example. There are several ways of approaching this situation (e.g., enforcing the agent&#39;s constraint <em>in addition</em> to the other agents&#39; bundles, or making sure the worst bundle is feasible for the agent in question).</p><p>Our (default) approach is to assume that the partitioning agent <em>doesn&#39;t know which bundles the others would choose</em>. She doesn&#39;t know their constraints, and so cannot apply them, and she doesn&#39;t know which bundle will be left for her, so she must apply her constraint to every bundle. In other words, finding the MMS becomes a maximin allocation problem where both the valuation function and the constraint of the agent in question is replicated, creating <span>$n$</span> &quot;clone agents&quot;. (For symmetric constraints, this is, of course, equivalent to the standard approach.)</p><p>The discrepancy in constraints between finding the MMS of each agent and finding an MMS allocation means that we can have situations where feasible allocations exist, but the MMS of one or more agents is not defined (because no feasible MMS partition exists). Because the duplicated constraints here represent the agent&#39;s ability to receive any of the bundles in the partition, and not the actual feasibility of the partition as an allocation, one strategy is to permit leaving some items out (cf. <a href="#generalized">the next section</a>) when finding the MMS partitions. See <a href="reference/#Allocations.alloc_mms"><code>alloc_mms</code></a> for more on this.</p><h2 id="generalized"><a class="docs-heading-anchor" href="#generalized">Generalized allocations</a><a id="generalized-1"></a><a class="docs-heading-anchor-permalink" href="#generalized" title="Permalink"></a></h2><p>Ordinarily, an allocation is assumed to be a partition of the items being allocated, with each item belonging to exactly one agent. <code>Allocation</code> objects, however, are capable of representing more general forms of allocations, where each item can belong to an arbitrary subset of the agents:</p><pre><code class="language-julia-repl hljs">julia&gt; A = Allocation(1 =&gt; 1, 2 =&gt; 1, 2 =&gt; 3)
Allocation with 2 agents and 3 items, 1 unallocated:
  1 =&gt; {1}
  2 =&gt; {1, 3}</code></pre><p>For <a href="reference/#MIP-based">methods relying on a mixed-integer programming solver</a>, such generalized allocations may be permitted by using the keyword arguments <code>min_bundle</code>, <code>max_bundle</code>, <code>min_owners</code> and <code>max_owners</code> (as described in the documentation of each method).</p><p>Allocating items to multiple agents is relevant, for example, in scenarios like reviewing papers for an academic conference (as discussed by <a href="https://doi.org/10.3233/978-1-60750-606-5-393">Lesca and Perny</a>), or, perhaps, allocating shifts to workers. Such scenarios can generally also be represented by duplicating the items, and adding a <a href="reference/#Allocations.Counts">cardinality constraint</a>, permitting each agent at most one copy of any item.</p><p>Allowing some items to remain unallocated (often thought of as being given to charity) can make a big difference to the problem being solved. Some <a href="reference/#Allocations.Constraint">constraints</a> may make it impossible to allocate all the items. For example, if a <a href="reference/#Allocations.Conflicts">conflict graph</a> with a high maximum degree is imposed, it may simply be impossible to allocate all items (cf. <a href="https://arxiv.org/abs/2104.06280">Hummel and Hetland</a>). If the feasible bundles of any agent form an <a href="https://en.wikipedia.org/wiki/Independence_system">independence system</a> (i.e., an empty bundle is feasible, and adding items can never repair an infeasible bundle), permitting charity ensures that an allocation is always possible.<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></p><p>When allocating goods with fairness criteria that maximize efficiency in some way (such as <a href="reference/#Allocations.alloc_lmm">leximin</a>, <a href="reference/#Allocations.alloc_mnw">MNW</a> or <a href="reference/#Allocations.alloc_ggi">GGI</a>), there will be a tendency towards not needlessly leaving items to charity. For purely envy-based criteria, however (such as <a href="reference/#Allocations.alloc_ef1-Tuple{Any, Any}">EF1</a> or <a href="reference/#Allocations.alloc_efx">EFX</a>), one might in principle end up satisfying the criterion by simply not allocating anything. In these cases, it might be better to combine with an efficiency optimization (such as, e.g., <a href="reference/#Allocations.alloc_mnw_ef1-Tuple{Any, Any}"><code>alloc_mnw_ef1</code></a>).</p><p><a href="reference/#Allocations.alloc_mm">Maximin</a> and <a href="reference/#Allocations.alloc_mms">MMS</a> are in a special position, here, in that they may leave items unallocated unnecessarily (i.e., not forced by a constraint), but simply distributing these items arbitrarily will not affect the validity of the solution. If, for some reason, charity were permitted with any of these in an unconstrained setting, any remaining items could simply be distributed using <a href="reference/#Allocations.fill_random!-Tuple{Any}"><code>fill_random!</code></a> or <a href="reference/#Allocations.fill_even!-Tuple{Any}"><code>fill_even!</code></a>.</p><div class="admonition is-info" id="Note-5f8c18cd557babc2"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-5f8c18cd557babc2" title="Permalink"></a></header><div class="admonition-body"><p>If you use <a href="reference/#Allocations.alloc_mm">maximin</a> or <a href="reference/#Allocations.alloc_mms">MMS</a> with a <a href="reference/#Allocations.Constraint">constraint</a>, distributing any leftover items is generally intractable, and probably best handled by the same solver that found the allocation to begin with. For maximin, you might consider simply switching to <a href="reference/#Allocations.alloc_lmm">leximin</a> (which will also return a maximin allocation).<sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup></p></div></div><h2 id="Solver-configuration"><a class="docs-heading-anchor" href="#Solver-configuration">Solver configuration</a><a id="Solver-configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-configuration" title="Permalink"></a></h2><p>Several allocation functions use mixed-integer linear programming via <a href="https://jump.dev">JuMP</a>. Depending on the choice of MIP solver, solving even moderately-sized instances may take a significant amount of time. Choosing a different solver (from the default <code>HiGHS.Optimizer</code>) may speed things up considerably. For example, with the appropriate license, one could use use <a href="https://www.gurobi.com">Gurobi</a> as follows:<sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup></p><pre><code class="language-julia hljs">Allocations.conf.MIP_SOLVER = Gurobi.Optimizer</code></pre><p>It is also possible to supply the <code>Optimizer</code> (or other optimizer factories, e.g., constructed using <code>optimizer_with_attributes</code>) as the <code>solver</code> keyword argument to the relevant allocation functions.</p><p>Normally, the MIP solvers will print out quite a lot of information about what they&#39;re doing. If you&#39;re not interested in this output, you can generally turn it off using some solver-specific flag, supplied to <code>optimizer_with_attributes</code>.<sup class="footnote-reference"><a id="citeref-5" href="#footnote-5">[5]</a></sup> This is also where you&#39;d supply other parameters, e.g., indicating time limits, acceptable inaccuracies, etc. For example:<sup class="footnote-reference"><a id="citeref-6" href="#footnote-6">[6]</a></sup></p><pre><code class="language-julia hljs">Allocations.conf.MIP_SOLVER = optimizer_with_attributes(
    Gurobi.Optimizer,
    &quot;LogToConsole&quot; =&gt; 0,     # No console output
    &quot;TimeLimit&quot; =&gt; 60,       # Finish within 60 seconds
    &quot;MipGap&quot; =&gt; 0.05,        # Permit 5% suboptimality
)</code></pre><p>If you&#39;re unable to get rid of the output using solver parameters, a simple solution is to just silence all output while allocating:</p><pre><code class="language-julia-repl hljs">julia&gt; redirect_stdout(devnull) do
           alloc_mnw(V)
       end</code></pre><p>If that doesn&#39;t do the trick, you could add <code>redirect_stderr</code> as well.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>The latter is less common, presumably because the two sets then intersect. An alternative is to let <span>$M$</span> be a set of opaque objects <span>$g_j$</span>, for <span>$j=1\dots m$</span>.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>The same is true of envy-based measures such as <a href="https://en.wikipedia.org/wiki/Envy-free_item_allocation">EFX</a>, which may not always exist even for unconstrained instances. (This is an open question at the time of writing.)</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>For MMS, there is currently no ready-made solution to ensure efficiency, though one could, for example, perform a two-step optimization (along the lines of <code>lex_optimize!</code>, found in <code>util.jl</code>). First, one would use <code>alloc_mms</code> and <code>mms_alpha</code> to find the MMS values of all agents and the proportion of the MMS guarantee attainable, and then one would add the appropriate constraints to ensure this proportion while maximizing some efficiency measure, e.g., the sum of utilities.</li><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a>If you&#39;re a student or a researcher, Gurobi is <a href="https://www.gurobi.com/academia">available for free under an academic license</a>.</li><li class="footnote" id="footnote-5"><a class="tag is-link" href="#citeref-5">5</a>There is also the <code>JuMP.set_silent</code> function, but it requires access to the MIP model.</li><li class="footnote" id="footnote-6"><a class="tag is-link" href="#citeref-6">6</a>See the <a href="https://www.gurobi.com/documentation/10.0/refman/parameters.html">Gurobi</a> manual for explanations.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.0 on <span class="colophon-date" title="Friday 9 May 2025 16:13">Friday 9 May 2025</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
