<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Allocations</title><meta name="title" content="Reference · Allocations"/><meta property="og:title" content="Reference · Allocations"/><meta property="twitter:title" content="Reference · Allocations"/><meta name="description" content="Documentation for Allocations."/><meta property="og:description" content="Documentation for Allocations."/><meta property="twitter:description" content="Documentation for Allocations."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Allocations</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Allocations.jl</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#types"><span>Basic types</span></a></li><li><a class="tocitem" href="#Checks-and-measures"><span>Checks and measures</span></a></li><li><a class="tocitem" href="#Allocation-algorithms"><span>Allocation algorithms</span></a></li><li><a class="tocitem" href="#MIP-based"><span>MIP-based allocation</span></a></li><li><a class="tocitem" href="#Instance-generation"><span>Instance generation</span></a></li><li><a class="tocitem" href="#Configuration"><span>Configuration</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mlhetland/Allocations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mlhetland/Allocations.jl/blob/master/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><pre><code class="language-julia-repl hljs">julia&gt; using Allocations</code></pre><p><strong>Function naming:</strong> Allocation functions that use a straightforward procedure, or simply use a solver to enforce some property, are named after that procedure or property (such as <code>alloc_rand</code> or <code>alloc_ef1</code>). For published algorithms, the package uses a naming scheme based on the original publication.</p><p>The root of the function name is <code>alloc_</code>, followed by a publication code:</p><ul><li>For a single-author paper, the first three letters of the author&#39;s last name are used;</li><li>for multi-author papers, the first letter of the first four authors are concatenated.</li><li>To this, the last two digits of the year are added.</li></ul><p>For example, the 2/3-MMS algorithm of Garg, McGlaughlin and Taki (2018) is implemented by <code>alloc_gmt18</code>.</p><ul><li><p>If the same code applies to multiple publications, they are distinguished by a suffix <code>a</code>, <code>b</code>, etc., after the year digits.</p></li><li><p>If a single publication discusses multiple algorithms, a number such as <code>_1</code>, <code>_2</code>, etc., is added. So, for example, the third algorithm described by Biswas and Barman (2018) is <code>alloc_bb18_3</code>.</p></li></ul><p>Some functions (such as <code>alloc_hh22_1</code>) are given generic names as aliases (in this case, <code>alloc_half_mms</code>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>These publication codes are similar to the <a href="https://en.wikipedia.org/wiki/Citation">authorship trigraphs used in some citation styles</a>. Specifically, they follow the conventions of <a href="http://tug.ctan.org/tex-archive/biblio/bibtex/base/alpha.bst"><code>alpha.bst</code></a>, except that an &quot;et al.&quot; character is not added when there are five or more authors.</p></div></div><p><strong>Accessors:</strong> Using accessors such as <code>attr(obj)</code> rather than <code>obj.attr</code> comes with the cost of claiming names in the global namespace, so they are mainly used when they provide some value, and not as a general convention. Such added value may be, for example, that it makes the interface clearer or more consistent, or that it provides some modest level of encapsulation. In many cases, it may also be worthwhile to use a function to access elements of an internal collection (such as <code>foo(X, i)</code> rather than <code>X.foo[i]</code>).</p><p>If, however, an object is essentially a named tuple, attributes will tend to be used without accessors. This applies to thin wrapper (such as <code>Conflicts</code>, for example), where the inner object is simply accessed directly.</p><p>Note that some such objects used accessors in earlier versions. These accessors are still available, but their use is deprecated. (Run <code>julia</code> with <code>--depwarn=true</code> to get the appropriate warnings.)</p><h2 id="types"><a class="docs-heading-anchor" href="#types">Basic types</a><a id="types-1"></a><a class="docs-heading-anchor-permalink" href="#types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Additive" href="#Allocations.Additive"><code>Allocations.Additive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Additive{T &lt;: AbstractMatrix} &lt;: Profile</code></pre><p>An additive valuation profile, representing how each agent values all possible bundles. Because of additivity, this is easily &quot;lifted&quot; from the values of individual items, by addition, with an empty bundle given a value of zero. By default, the profile is constructed from a real matrix <code>X</code>, supplied to the default constructor, where <code>X[i, g]</code> is agent <code>i</code>&#39;s value for item <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L542-L550">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Additive-Tuple{Any, Any}" href="#Allocations.Additive-Tuple{Any, Any}"><code>Allocations.Additive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Additive(n, m)</code></pre><p>Create an additive profile for <code>n</code> agents and <code>m</code> items where all values are set to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L556-L561">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Allocation" href="#Allocations.Allocation"><code>Allocations.Allocation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Allocation &lt;: Any</code></pre><p>A mapping <code>A</code> from agents <code>i</code> to their assigned bundles <code>bundle(A, i)</code>. Agents and items are represented as <code>Int</code>s, and bundles as <code>Set</code>s of <code>Int</code>s. The <code>Allocation</code> also maintains an inverse mapping, from items <code>g</code> to their set of owners, <code>owners(A, g)</code>. To keep these in sync, the bundles should be modified using <code>give!</code> and <code>deny!</code>, rather than altering the bundle sets directly.</p><p><code>Allocation</code>s support iteration (along with <code>length</code> and <code>isempty</code>), which acts as for a map from agents to bundles, i.e., it generates a series of pairs <code>i =&gt; S</code>, where <code>i</code> is an agent, and <code>S</code> is the corresponding bundle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L111-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Allocation" href="#Allocations.Allocation"><code>Allocations.Allocation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Allocation(n::Int, m::Int[, bundles])
Allocation(n::Int, m::Int, bundles::Pair...)</code></pre><p>Construct an empty allocation with <code>n</code> agents and <code>m</code> items. If the <code>bundles</code> argument is provided, it should be iterable, with length-2 elements, such as <code>Pair</code>s or 2-tuples <code>(i, x)</code> or agents <code>i</code> and bundles – or individual items – <code>x</code> they should receive. Agents may occur multiple times, and will then receive all the bundles or items specified. These bundle assignments need not form a partition of the item set.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Allocation(5, 10, [1 =&gt; [1, 2, 3]])
Allocation with 5 agents and 10 items, 7 unallocated:
  1 =&gt; {1, 2, 3}
  2 =&gt; {}
  3 =&gt; {}
  4 =&gt; {}
  5 =&gt; {}</code></pre><p>The bundles assignment pairs may also be provided as individual <code>Pair</code>s:</p><pre><code class="nohighlight hljs">julia&gt; Allocation(3, 3, 1 =&gt; [2], 2 =&gt; [3, 1], 3 =&gt; 2, 3 =&gt; 3)
Allocation with 3 agents and 3 items:
  1 =&gt; {2}
  2 =&gt; {1, 3}
  3 =&gt; {2, 3}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L149-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Allocation-Tuple{Allocation}" href="#Allocations.Allocation-Tuple{Allocation}"><code>Allocations.Allocation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Allocation(A::Allocation)</code></pre><p>Construct a new allocation that has the same agents, items and bundles as <code>A</code>. Because an <code>Allocation</code> is an iterable collection of agent–bundle pairs, this is equivalent to the more general <code>Allocation(bundles)</code> constructor, just slightly more efficient, because the number of agents and items are retrieved directly from <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L227-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Allocation-Tuple{Any}" href="#Allocations.Allocation-Tuple{Any}"><code>Allocations.Allocation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Allocation(bundles)
Allocation(bundles::Pair...)</code></pre><p>Equivalent to <code>Allocation(n, m, bundles)</code>, where <code>n</code> and <code>m</code> are determined from the <code>bundles</code> argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Allocation([1 =&gt; [1, 2, 3]])
Allocation with 1 agent and 3 items:
  1 =&gt; {1, 2, 3}

julia&gt; Allocation(1 =&gt; [2], 2 =&gt; [3, 1], 3 =&gt; 2, 3 =&gt; 3)
Allocation with 3 agents and 3 items:
  1 =&gt; {2}
  2 =&gt; {1, 3}
  3 =&gt; {2, 3}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L193-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Allocation-Tuple{Profile, Vararg{Any}}" href="#Allocations.Allocation-Tuple{Profile, Vararg{Any}}"><code>Allocations.Allocation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Allocation(V::Profile, args...)</code></pre><p>Construct an allocation with a number of agents and items equal to that of the instance (i.e., profile) <code>V</code>. Additional arguments may be provided as for the constructor with explicit <code>n</code> and <code>m</code> arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; V = Profile([1 2; 2 1])
Additive{Matrix{Int64}} with 2 agents and 2 items:
 1  2
 2  1

julia&gt; A = Allocation(V, 1 =&gt; 2)
Allocation with 2 agents and 2 items, 1 unallocated:
  1 =&gt; {2}
  2 =&gt; {}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L447-L468">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Allocation-Tuple{}" href="#Allocations.Allocation-Tuple{}"><code>Allocations.Allocation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Allocation()</code></pre><p>Construct an empty allocation with zero agents and items.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Category" href="#Allocations.Category"><code>Allocations.Category</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Category</code></pre><p>One of the categories in a <code>Counts</code> constraint, from which each agent can hold at most a given number of items. The category supports iteration (over its members), and the threshold is available through the <code>threshold</code> attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L717-L723">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Conflicts" href="#Allocations.Conflicts"><code>Allocations.Conflicts</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Conflicts{T &lt;: AbstractGraph} &lt;: Constraint</code></pre><p>A kind of constraint – or set of constraints – that indicates that certain items conflict, and thus cannot be allocated to the same agent. The constraints are represented as a <em>conflict graph</em> (<code>Graphs.AbstractGraph</code>), with items as nodes, and edges representing conflicts. The <code>Conflicts</code> type is just a wrapper for dispatch purposes, with the underlying graph available through the <code>graph</code> attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L818-L827">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Constraint" href="#Allocations.Constraint"><code>Allocations.Constraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Constraint &lt;: Any</code></pre><p>Abstract supertype of various kinds of constraints. An instance of the allocation problem is assumed to consist of a <code>Profile</code> object and at most one <code>Constraint</code> object, embodying any and all constraints placed on feasible solutions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L690-L697">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Constraints" href="#Allocations.Constraints"><code>Allocations.Constraints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Constraints{T &lt;: Tuple{Vararg{Constraint}}} &lt;: Constraint</code></pre><p>A thin wrapper around a tuple of constraints, acting as a single, combined constraint. May be constructed with a single tuple argument, or with zero or more <code>Constraint</code> objects. Its meaning is the conjunction of its constituent parts. That is, an allocation that is to satisfy <code>Constraints(A, B)</code> would need to satisfy both <code>A</code> and <code>B</code>. The wrapped tuple is available via the <code>parts</code> attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L701-L710">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Counts" href="#Allocations.Counts"><code>Allocations.Counts</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Counts{T} &lt;: Constraint</code></pre><p>The <em>cardinality constraints</em> used by Biswas and Barman in their 2018 paper <a href="https://www.ijcai.org/proceedings/2018/13">Fair Division Under Cardinality Constraints</a>. This is a form of constraint consisting of several <code>Category</code> objects, available through indexing or iteration. Any agent may hold at most a given number of items from any given category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L789-L798">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Counts-Tuple{Vararg{Pair}}" href="#Allocations.Counts-Tuple{Vararg{Pair}}"><code>Allocations.Counts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Counts(args::Pair...)</code></pre><p>Create a <code>Counts</code> object where each pair <code>x =&gt; k</code> becomes a category with members <code>Set(x)</code> and threshold <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L804-L809">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Forbidden" href="#Allocations.Forbidden"><code>Allocations.Forbidden</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Forbidden{T} &lt;: Constraint</code></pre><p>An exclusion constraint, which specifies objects that agents are forbidden from receiving. These object sets are simply specified by an <code>Allocation</code> (or an <code>Allocation</code>-like object), provided to the constructor.</p><p>This constraint is asymmetric (see <a href="../#Symmetry"><code>Symmetry</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L833-L841">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.OrderedCategory" href="#Allocations.OrderedCategory"><code>Allocations.OrderedCategory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct OrderedCategory</code></pre><p>Used in place of <code>Category</code> when handling an ordered instance. The instance is assumed to be such that items in the range <code>index:index + n_items - 1</code> belong to the given category, i.e., the items of a category occupy a contiguous range of integers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L734-L741">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Permitted" href="#Allocations.Permitted"><code>Allocations.Permitted</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Permitted{T} &lt;: Constraint</code></pre><p>A constraint that specifies objects that agents are permitted to receive, implicitly forbidding all others (cf. <a href="#Allocations.Forbidden"><code>Forbidden</code></a>). These object sets are simply specified by an <code>Allocation</code> (or an <code>Allocation</code>-like object), provided to the constructor.</p><p>This constraint is asymmetric (see <a href="../#Symmetry"><code>Symmetry</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L848-L857">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Profile" href="#Allocations.Profile"><code>Allocations.Profile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Profile &lt;: Any</code></pre><p>An abstract type representing an valuation profile. Which functions are used to query it depends on the kind of valuation functions it represents. Additive valuations act on individual objects, and simply sum those values over a bundle, but profiles with quite different kinds of queries are possible for valuations with other properties (see, e.g., <a href="https://dl.acm.org/doi/10.1145/3219166.3219238">Fair Allocation of Indivisible Goods: Improvements and Generalizations</a> by Ghodsi et al., 2018).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L432-L443">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Profile-Tuple{Matrix}" href="#Allocations.Profile-Tuple{Matrix}"><code>Allocations.Profile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Profile(X::Matrix)</code></pre><p>Alias for <code>Additive(X)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L565-L569">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Reduction" href="#Allocations.Reduction"><code>Allocations.Reduction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Reduction{S, T, I, G}</code></pre><p>A reduction from one instance of a fair allocation problem to another. Contains information about the profiles in the reduced instance, through an object of type <code>S</code>. There must exist functions <code>agents(s::S)</code> and <code>items(s::S)</code> that return iterators of, respectively, the agents and items in the reduced instance. The reduction can also contain information about the constraints in the reduced instance, through an object of type <code>T</code>.</p><p>In addition, the reduction contains two mappings (vectors), <code>λi</code> (of type <code>I</code>) and <code>λg</code> (of type <code>G</code>). Both types should be indexable (for <code>i ∈ agents(s)</code> and <code>g ∈ items(s)</code>, respectively). <code>λi[i]</code> and <code>λg[g]</code> should return the agent and item identifier in the original instance of, respectively, agent <code>i</code> and item <code>g</code> in the reduced instance.</p><p>The reduction also contains a function that can convert an allocation in the reduced instance to one in the original instance.</p><p>The default constructor is <code>Reduction(V, C, λi, λg, transform::Function)</code>, for a profile <code>V</code> and constraint <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L882-L903">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Reduction-NTuple{4, Any}" href="#Allocations.Reduction-NTuple{4, Any}"><code>Allocations.Reduction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Reduction(V, λi, λg, transform)</code></pre><p>A simplified constructor for when there are no constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L913-L917">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Reduction-Tuple{Any, Any}" href="#Allocations.Reduction-Tuple{Any, Any}"><code>Allocations.Reduction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Reduction(V, C)</code></pre><p>A simplified constructor for when either no changes have been performed or changes only concern the profiles and/or constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L921-L926">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Reduction-Tuple{Any}" href="#Allocations.Reduction-Tuple{Any}"><code>Allocations.Reduction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Reduction(V)</code></pre><p>A simplified constructor for when either no changes have been performed or changes only concern the profiles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L930-L935">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Reduction-Tuple{Reduction, Any}" href="#Allocations.Reduction-Tuple{Reduction, Any}"><code>Allocations.Reduction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Reduction(R::Reduction, C)</code></pre><p>A simplified constructor to create a copy of a reduction with constraints attached.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L938-L943">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Required" href="#Allocations.Required"><code>Allocations.Required</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Required{T} &lt;: Constraint</code></pre><p>An inclusion constraint, which specifies objects that agents are required to receive. These object sets are simply specified by an <code>Allocation</code> (or an <code>Allocation</code>-like object), provided to the constructor.</p><p>This constraint is asymmetric (see <a href="../#Symmetry"><code>Symmetry</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L864-L872">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Submodular" href="#Allocations.Submodular"><code>Allocations.Submodular</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Submodular &lt;: Profile</code></pre><p>A submodular valuation profile, representing how each agent values all possible bundles. The profile is constructed from a set of <code>n</code> submodular valuation functions, one per agent, as well as the number of items, <code>m</code>. The profile functions should, when supplied with a <code>Set</code> of items (a subset of <code>1:m</code>), return the value of that set of items to the given agent (i.e., acting as so-called <em>query oracles</em>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L663-L672">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.Symmetry" href="#Allocations.Symmetry"><code>Allocations.Symmetry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Symmetry(instance)
Symmetry(T::Type)</code></pre><p>Indicate whether a constraint instance or type is symmetric or asymmetric (indicated by a return value of <code>Symmetric()</code> or <code>Asymmetric()</code>, where <code>Symmetric</code> and <code>Asymmetric</code> are empty concrete subtypes of <code>Symmetry</code>). A symmetric constraint is one that is invariant under permutation of the agents, while an asymmetric constraint is not. That is, an asymmetric constraint is one that permits individual variations in the constraints placed on the bundles of different agents.</p><p>An instance has the same asymmetry as its type, and by default, this is <code>Symmetric()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L78-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.agent-Tuple{Reduction, Any}" href="#Allocations.agent-Tuple{Reduction, Any}"><code>Allocations.agent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">agent(R::Reduction, i)</code></pre><p>Converts the agent identifier <code>i</code> from the reduced instance to the agent identifier of the same agent in the original instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L956-L961">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.agents-Tuple{Any}" href="#Allocations.agents-Tuple{Any}"><code>Allocations.agents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">agents(X)</code></pre><p>Returns the set of agents associated with (e.g., profile or allocation) <code>X</code>), as an iterable of <code>Int</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.bundle-Tuple{Any, Any}" href="#Allocations.bundle-Tuple{Any, Any}"><code>Allocations.bundle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bundle(A, i)</code></pre><p>The set of items allocated to agent <code>i</code> in the allocation <code>A</code>. The returned <code>Set</code> should be treated as read-only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L317-L322">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.ceil_n-Tuple{OrderedCategory, Any}" href="#Allocations.ceil_n-Tuple{OrderedCategory, Any}"><code>Allocations.ceil_n</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ceil_n(c::OrderedCategory, n)</code></pre><p>One <code>n</code>th of the number of items in the category, rounded up.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L771-L775">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.chain-Tuple{Reduction, Reduction}" href="#Allocations.chain-Tuple{Reduction, Reduction}"><code>Allocations.chain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chain(R₁::Reduction, R₂::Reduction)</code></pre><p>Assumes that R₂ is a reduction of the reduced instance of R₁. Combines the two reductions, so that the original instance is the original instance of R₁ and the reduced instance is the reduced instance of R₂ (essentially diagram-order composition of the reductions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L974-L981">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.deny!-Tuple{Any, Any, Any}" href="#Allocations.deny!-Tuple{Any, Any, Any}"><code>Allocations.deny!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deny!(A, i, g)</code></pre><p>Deny agent <code>i</code> the object <code>g</code>, which it has previously been given, in the allocation <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L378-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.fill_even!-Tuple{Any}" href="#Allocations.fill_even!-Tuple{Any}"><code>Allocations.fill_even!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fill_even!(A)</code></pre><p>Fill out the allocation by distributing the unallocated items evenly, by repeatedly giving the next unallocated item to the agent with the fewest items (ties broken arbitrarily).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L391-L397">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.fill_random!-Tuple{Any}" href="#Allocations.fill_random!-Tuple{Any}"><code>Allocations.fill_random!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fill_random!(A)</code></pre><p>Fill out the allocation by distributing the unallocated items randomly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L414-L418">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.floor_n-Tuple{OrderedCategory, Any}" href="#Allocations.floor_n-Tuple{OrderedCategory, Any}"><code>Allocations.floor_n</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floor_n(c::OrderedCategory, n)</code></pre><p>One <code>n</code>th of the number of items in the category, rounded down.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L763-L767">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.give!-Tuple{Any, Any, Any}" href="#Allocations.give!-Tuple{Any, Any, Any}"><code>Allocations.give!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">give!(A, i, B)</code></pre><p>Give agent <code>i</code> the bundle <code>B</code> in the <code>Allocation</code> <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L364-L368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.give!-Tuple{Any, Any, Int64}" href="#Allocations.give!-Tuple{Any, Any, Int64}"><code>Allocations.give!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">give!(A, i, g::Int)</code></pre><p>Give agent <code>i</code> the object <code>g</code> in the <code>Allocation</code> <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L352-L356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.isintegral" href="#Allocations.isintegral"><code>Allocations.isintegral</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isintegral(V::Profile)</code></pre><p>Test whether every value provided by <code>V</code> is an integer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L515-L519">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.isnonnegative" href="#Allocations.isnonnegative"><code>Allocations.isnonnegative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isnonnegative(V::Profile)</code></pre><p>Test whether every value provided by <code>V</code> is nonnegative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L523-L527">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.item-Tuple{Reduction, Any}" href="#Allocations.item-Tuple{Reduction, Any}"><code>Allocations.item</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">item(R::Reduction, g)</code></pre><p>Converts the item identifier <code>g</code> from the reduced instance to the item identifier of the same item in the original instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L965-L970">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.items-Tuple{Any}" href="#Allocations.items-Tuple{Any}"><code>Allocations.items</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">items(X)</code></pre><p>Returns the set of items associated with (e.g., profile or allocation) <code>X</code>, as an iterable of <code>Int</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.matrix-Tuple{Additive}" href="#Allocations.matrix-Tuple{Additive}"><code>Allocations.matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix(V::Additive)</code></pre><p>Return the underlying valuation matrix of <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L646-L650">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.matrix-Tuple{Profile}" href="#Allocations.matrix-Tuple{Profile}"><code>Allocations.matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix(V::Profile)</code></pre><p>Return a matrix <code>X</code> where <code>X[i, g]</code> is <code>value(V, i, g)</code>. May not be very useful in general (especially if calculating single-item values isn&#39;t efficient to begin with), but if such a matrix is available as part of the profile implementation (as with <code>Additive</code>), it may be returned directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L531-L538">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.na" href="#Allocations.na"><code>Allocations.na</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">na(X)</code></pre><p>The number of agents represented by (e.g., profile or allocation) <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.ni" href="#Allocations.ni"><code>Allocations.ni</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ni(X)</code></pre><p>The number of items represented by (e.g., profile or allocation) <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.normalize-Tuple{Additive}" href="#Allocations.normalize-Tuple{Additive}"><code>Allocations.normalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalize(V::Additive)</code></pre><p>Scale the values of <code>V</code> such that <span>$v_i(M) = n$</span> for all agents <span>$i$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L654-L658">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.owned-Tuple{Any, Any}" href="#Allocations.owned-Tuple{Any, Any}"><code>Allocations.owned</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">owned(A, g)</code></pre><p>Whether or not the item <code>g</code> is owned by any agent in the allocation <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L344-L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.owner-Tuple{Any, Any}" href="#Allocations.owner-Tuple{Any, Any}"><code>Allocations.owner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">owner(A, g)</code></pre><p>The agent to which item <code>g</code> has been allocated in the allocation <code>A</code>. Will produce an error if <code>g</code> has been allocated to more than one agent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L335-L340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.owners-Tuple{Any, Any}" href="#Allocations.owners-Tuple{Any, Any}"><code>Allocations.owners</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">owners(A, g)</code></pre><p>The set of agents to which item <code>g</code> has been allocated in the allocation <code>A</code>. The returned <code>Set</code> should be treated as read-only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L326-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.required-Tuple{OrderedCategory, Any}" href="#Allocations.required-Tuple{OrderedCategory, Any}"><code>Allocations.required</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">required(c::OrderedCategory, n)</code></pre><p>The number of items the next agent must take in order to keep the instance valid, i.e., for there to be a maximum of <code>(n - 1) * threshold</code> remaining items.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L779-L785">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.transform-Tuple{Reduction, Allocation}" href="#Allocations.transform-Tuple{Reduction, Allocation}"><code>Allocations.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform(R::Reduction, A::Allocation)</code></pre><p>Converts the given allocation for the reduced instance to one for original instance. The way the convertion occurs depends on the given reduction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L947-L952">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.value" href="#Allocations.value"><code>Allocations.value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">value(V::Profile, i, S)
value(V::Profile, i, g::Int)</code></pre><p>The value agent <code>i</code> places on bundle <code>S</code>, according to the profile <code>V</code>. The second form is a shortcut for <code>value(V, i, [g])</code>; the shortcut will generally be more efficient. Note that the value of <code>S</code> may <em>not</em> in general be the sum of the values of its items; that property is unique to <code>Additive</code> profiles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L472-L480">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.value!-Tuple{Additive, Any, Any, Any}" href="#Allocations.value!-Tuple{Additive, Any, Any, Any}"><code>Allocations.value!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value!(V::Additive, i, g::Int, v)</code></pre><p>Set the value of item <code>g</code>, according to agent <code>i</code>, to <code>v</code> in profile <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L638-L642">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.value-Tuple{Additive, Any, Int64}" href="#Allocations.value-Tuple{Additive, Any, Int64}"><code>Allocations.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value(V::Additive, i, g::Int)</code></pre><p>The value of item <code>g</code>, according to agent <code>i</code> under valuation profile <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L597-L601">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.value-Tuple{Profile, Any, Allocation}" href="#Allocations.value-Tuple{Profile, Any, Allocation}"><code>Allocations.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value(V::Profile, i, A::Allocation)</code></pre><p>The value agent <code>i</code> receives in allocation <code>A</code>, under the profile <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L484-L488">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.value-Union{Tuple{T}, Tuple{Additive, Any, T}} where T&lt;:(AbstractMatrix)" href="#Allocations.value-Union{Tuple{T}, Tuple{Additive, Any, T}} where T&lt;:(AbstractMatrix)"><code>Allocations.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value(V::Additive, i, A::T) where {T &lt;: AbstractMatrix}</code></pre><p>Similar to the case where <code>A</code> is an <code>Allocation</code>, except the allocation is expressed as a binary matrix, where <code>A[i, g]</code> indicates whether <code>i</code> has item <code>g</code> (<code>1</code>) or not (<code>0</code>). May also be used, e.g., with a matrix of variable references, when constructing MIPs with JuMP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L609-L616">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.value_1" href="#Allocations.value_1"><code>Allocations.value_1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">value_1(V::Profile, i, S)</code></pre><p>The value agent <code>i</code> places on bundle <code>S</code>, <em>up to one item</em>, that is, the smallest value <code>i</code> can place on bundle <code>S</code> after removing (at most) one item, according to the profile <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L495-L501">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.value_x" href="#Allocations.value_x"><code>Allocations.value_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">value_x(V::Profile, i, S)</code></pre><p>The value agent <code>i</code> places on bundle <code>S</code>, <em>up to any item</em>, that is, the largest value <code>i</code> can place on bundle <code>S</code> after removing one item (or no items, if the bundle is empty), according to the profile <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L505-L511">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copy-Tuple{Allocation}" href="#Base.copy-Tuple{Allocation}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy(A::Allocation)</code></pre><p>Creates a new allocation that has the same agents, items and bundles as <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/types.jl#L141-L145">source</a></section></article><h2 id="Checks-and-measures"><a class="docs-heading-anchor" href="#Checks-and-measures">Checks and measures</a><a id="Checks-and-measures-1"></a><a class="docs-heading-anchor-permalink" href="#Checks-and-measures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.check" href="#Allocations.check"><code>Allocations.check</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check(V, A, C)</code></pre><p>Check that the allocation <code>A</code> obeys the <code>Constraint</code> <code>C</code>, given the profile <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/checks.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.check-Tuple{Any, Any, Conflicts}" href="#Allocations.check-Tuple{Any, Any, Conflicts}"><code>Allocations.check</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check(V, A, C::Conflicts)</code></pre><p>Check whether the allocation <code>A</code> respects the item conflicts <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/checks.jl#L123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.check-Tuple{Any, Any, Counts}" href="#Allocations.check-Tuple{Any, Any, Counts}"><code>Allocations.check</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check(V, A, C::Counts)</code></pre><p>Check whether the allocation <code>A</code> respects the cardinality constraints <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/checks.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.check-Tuple{Any, Any, Nothing}" href="#Allocations.check-Tuple{Any, Any, Nothing}"><code>Allocations.check</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check(V, A, C::Nothing)</code></pre><p>Trivial check that <code>A</code> satisfies a null-constraint. Always returns true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/checks.jl#L91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.check_complete-Tuple{Any}" href="#Allocations.check_complete-Tuple{Any}"><code>Allocations.check_complete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_complete(A)</code></pre><p>Check that the allocation is complete, or effective, in the sense that each item has been allocated to at least one agent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/checks.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.check_ef-Tuple{Any, Any}" href="#Allocations.check_ef-Tuple{Any, Any}"><code>Allocations.check_ef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_ef(V, A)</code></pre><p>Check whether the allocation <code>A</code> is <em>envy-free</em> for the profile <code>V</code>, i.e., if no agent strictly prefers another agent&#39;s bundle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/checks.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.check_ef1-Tuple{Any, Any}" href="#Allocations.check_ef1-Tuple{Any, Any}"><code>Allocations.check_ef1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_ef1(V, A)</code></pre><p>Check whether the allocation <code>A</code> is <em>envy-free up to one item</em> for the profile <code>V</code>, i.e., if no agent strictly prefers another agent&#39;s bundle, given that an appropriate (e.g., the most valuable) item is removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/checks.jl#L63-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.check_efx-Tuple{Any, Any}" href="#Allocations.check_efx-Tuple{Any, Any}"><code>Allocations.check_efx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_efx(V, A)</code></pre><p>Check whether the allocation <code>A</code> is <em>envy-free up to any item</em> for the profile <code>V</code>, i.e., if no agent strictly prefers another agent&#39;s bundle, given that an appropriate (e.g., the least valuable) item is removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/checks.jl#L73-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.check_partition-Tuple{Any}" href="#Allocations.check_partition-Tuple{Any}"><code>Allocations.check_partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_partition(A)</code></pre><p>Check that the allocation is a partition, i.e., that each item has been allocated to exactly one agent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/checks.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.ef1_alpha-Tuple{Any, Any}" href="#Allocations.ef1_alpha-Tuple{Any, Any}"><code>Allocations.ef1_alpha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ef1_alpha(V, A)</code></pre><p>Find the approximation factor for <em>envy-freeness up to one item</em> in the allocation <code>A</code> with the valuation profile <code>V</code>, i.e., how close to EF1 each agent is guaranteed to get.</p><p>If every agent values all other agents&#39; bundles as <code>0</code>, the <code>alpha</code> returned by this function will be <code>Inf</code>. This is the case even if the agents also value their own bundles as <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/measures.jl#L74-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.ef_alpha-Tuple{Any, Any}" href="#Allocations.ef_alpha-Tuple{Any, Any}"><code>Allocations.ef_alpha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ef_alpha(V, A)</code></pre><p>Find the approximation factor for <em>envy-freeness</em> in the allocation <code>A</code> with the valuation profile <code>V</code>, i.e., how close to envy-freeness each agent is guaranteed to get.</p><p>If every agent values all other agents&#39; bundles as <code>0</code>, the <code>alpha</code> returned by this function will be <code>Inf</code>. This is the case even if the agents also value their own bundles as <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/measures.jl#L60-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.efx_alpha-Tuple{Any, Any}" href="#Allocations.efx_alpha-Tuple{Any, Any}"><code>Allocations.efx_alpha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">efx_alpha(V, A)</code></pre><p>Find the approximation factor for <em>envy-freeness up to any item</em> in the allocation <code>A</code> with the valuation profile <code>V</code>, i.e., how close to EFX each agent is guaranteed to get.</p><p>If every agent values all other agents&#39; bundles as <code>0</code>, the <code>alpha</code> returned by this function will be <code>Inf</code>. This is the case even if the agents also value their own bundles as <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/measures.jl#L88-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.nash_welfare-Tuple{Any, Any}" href="#Allocations.nash_welfare-Tuple{Any, Any}"><code>Allocations.nash_welfare</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nash_welfare(V, A; nonzero=true)</code></pre><p>Compute the Nash welfare of the allocation <code>A</code>, given the profile <code>V</code>, i.e., the product of the individual agent utilities resulting from <code>A</code>. The <code>nonzero</code> keyword indicates that agents with a utility of zero are left out. If no agents with nonzero utility exist, the result is zero. To avoid overflow with large utilities, the product is performed using floating-point arithmetic, even if the utilities are integral.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/measures.jl#L14-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.prop_alpha-Tuple{Any, Any}" href="#Allocations.prop_alpha-Tuple{Any, Any}"><code>Allocations.prop_alpha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prop_alpha(V, A)</code></pre><p>Compute the fraction of proportionality guaranteed to every agent, that is, what fraction each agent is guaranteed to get of <code>1/n</code> of their value for the grand bundle <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/measures.jl#L36-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.utility-Tuple{Any, Any}" href="#Allocations.utility-Tuple{Any, Any}"><code>Allocations.utility</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">utility(V, A)</code></pre><p>Compute the utilitarian welfare of the allocation <code>A</code>, given the profile <code>V</code>, i.e., the sum of the individual agent utilities (i.e., the bundle values) resulting from <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/measures.jl#L4-L10">source</a></section></article><h2 id="Allocation-algorithms"><a class="docs-heading-anchor" href="#Allocation-algorithms">Allocation algorithms</a><a id="Allocation-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Allocation-algorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_bb18_3-Tuple{Additive, Counts}" href="#Allocations.alloc_bb18_3-Tuple{Additive, Counts}"><code>Allocations.alloc_bb18_3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_bb18_3(V::Additive, C::Counts; a=3, ghss18_4b_warn=true)</code></pre><p>The 1/3-approximate MMS-allocation under cardinality constraints algorithm (Section 5) described by Biswas and Barman in their 2018 paper <a href="https://doi.org/10.24963/ijcai.2018/13">Fair Division Under Cardinality Constraints</a>. Finds a 1/3-approximate MMS allocation for an instance of the fair allocation problem under cardinality constraints by converting the additive instance under cardinality constraints to a submodular instance without cardinality constraints. The allocation is then found by using the method of Ghodsi et al. (<code>alloc_ghss18_4b</code>), with possible reallocation of items to satisfy the constraints. Both keyword arguments, <code>a</code> and <code>ghss18_4b_warn</code>, are passed directly to <code>alloc_ghss18_4b</code> as respectively the keyword arguments <code>a</code> and <code>x_warn</code>. See <a href="#Allocations.alloc_ghss18_4b-Tuple{Submodular}"><code>alloc_ghss18_4b</code></a> for documentation on how to use them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/algorithms.jl#L631-L645">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_bkv18_1-Tuple{Any}" href="#Allocations.alloc_bkv18_1-Tuple{Any}"><code>Allocations.alloc_bkv18_1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_bkv18_1(V; randpri=true)</code></pre><p>The first algorithm (<strong>Alg-Identical</strong>) described by Barman, Krishnamurty and Vaish in their 2018 paper <a href="http://arxiv.org/abs/1801.09046">Greedy Algorithms for Maximizing Nash Social Welfare</a>. The algorithm finds a 1.061-approximate MNW allocation when agents have identical valuations, i.e., for any agents <code>i</code>, <code>j</code> and item <code>g</code>, <code>value(V, i, g) == value(V, j, g)</code>. (This approximation ratio applies to the geometric mean of agent utilities, not the raw product.) The result will also be envy-free up to any item (EFX).</p><p>The algorithm follows a straightforward greedy allocation procedure, where in each iteration, the most valuable item is allocated to the agent with the lowest utility. By default, ties are broken by giving the agents random priorities; if <code>randpri</code> is set to false, they are instead broken lexicographically (as specified by Barman et al.), so that the agent with the lower index is preferred.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/algorithms.jl#L222-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_bkv18_2-Tuple{Any}" href="#Allocations.alloc_bkv18_2-Tuple{Any}"><code>Allocations.alloc_bkv18_2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_bkv18_2(V; randpri=true, complete=false)
alloc_hpps20_1(V; randpri=true, complete=false) # alias</code></pre><p>The second algorithm (<strong>Alg-Binary</strong>) described by Barman, Krishnamurty and Vaish in their 2018 paper <a href="http://arxiv.org/abs/1801.09046">Greedy Algorithms for Maximizing Nash Social Welfare</a>. The algorithm finds MNW allocations in polynomial time for binary additive valuations, i.e., where each agent values any given object at 0 or 1 (e.g., an <code>Additive{BitMatrix}</code>). It also works in a more general setting, where <code>value(V, i, S)</code>, for any given <code>i</code>, is a concave function of the number of items <code>g</code> in <code>S</code> for which <code>value(V, i, g) == 1</code>.</p><p>The original algorithm builds on an initial allocation, but does not specify what this allocation should be. It also does not deal with the case where one or more agents ends up with zero utility; in fact the procedure will not work even if we start with two or more agents with zero utility in the intial allocation. The strategy followed here is the same as that of <a href="https://doi.org/10.1145/3355902">Caragiannis et al.</a>, where a maximum cardinality set of agents achieving positive utility is found using bipartite matching (with no fairness considerations). The remaining items are randomly allocated to agents among these that value them, if any. Remaining agents and items are ignored by the procedure.</p><p>Following the algorithm of Barman et al., the tie-breaking procedure (Algorithm 1) of <a href="http://arxiv.org/abs/2007.06073">Halpern et al.</a> is used, where the MNW allocation is transformed into the lexicographically greatest MNW, according to some ordering of the agents, providing group-strategyproofness (GSP) in addition to the EF1 and PO guarantees that follow from MNW. By default, the agent ordering/priority is random; if this randomization is turned off (with <code>randpri</code> set to false), the default ordering is used, with agent <code>1</code> receiving the highest priority, etc.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Despite the use of randomization here, by default, this is the <em>deterministic</em> procedure of Halpern et al. They also describe a randomized procedure, which functions in an entirely different manner.</p></div></div><p>Finally, if the <code>complete</code> argument is set to <code>true</code>, the allocation is completed with <code>fill_even!</code> (which means that some agents that must necessarily get a utility of zero can still receive items valued zero, if that evens out the bundle cardinalities). Note that this undermines the GSP guarantee, which requires that these items be discarded. The return value is a named tuple with the fields <code>alloc</code> (the <code>Allocation</code>) and <code>mnw</code> (the Nash welfare, ignoring agents with zero utility).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/algorithms.jl#L272-L317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_ghss18_4-Tuple{Submodular, Any}" href="#Allocations.alloc_ghss18_4-Tuple{Submodular, Any}"><code>Allocations.alloc_ghss18_4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_ghss18_4(V::Submodular, MMSs)</code></pre><p>The fourth algorithm (<strong>Algorithm 4</strong>) described by Ghodsi et al. in the 2018 paper <a href="https://arxiv.org/abs/1704.00222">Fair allocation of Indivisible Goods: Improvements and Generalizations</a>. The algorithm finds a 1/3-approximate MMS allocation for a given submodular instance and corresponding maximin shares for the agents (<code>MMSs[i]</code> should be the MMS of agent <code>i</code>). If the supplied maximin shares, are higher than the actual maximin shares, the method may fail. In that case, this will be indicated in the result, where <code>res.fail</code> will be set to true and <code>res.agent</code> will be set to the agent last considered when the method failed to improve. If the maximin shares are unknown, use <code>alloc_ghss18_4b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/algorithms.jl#L499-L512">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_ghss18_4b-Tuple{Submodular}" href="#Allocations.alloc_ghss18_4b-Tuple{Submodular}"><code>Allocations.alloc_ghss18_4b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_ghss18_4b(V::Submodular; a=3, x_warn=true)</code></pre><p>A variation on the fourth algorithm (<strong>Algorithm 4</strong>) described by Ghodsi et al. in the 2018 paper <a href="https://arxiv.org/abs/1704.00222">Fair allocation of Indivisible Goods: Improvements and Generalizations</a>. The algorithm finds a 1/3-approximate MMS allocation for a given submodular instance. The method starts by overestimating the MMS of each agent and slowly decreasing the MMS of specific agents until <code>alloc_ghss18_4</code> returns an allocation.</p><p>The amount that the MMS of an agent should be reduced by in each iteration is not specified by Ghodsi et al. One can show that if the factor is <code>1/(1 + 1/x)</code>, where <code>x ≥ 3n - 1</code>, then the algorithm will successfully find a 1/3-approximate MMS allocation. One way to show this, is to modify Lemma 4.6 in their paper to assume that each of the bundles <code>Sᵢ</code> is valued at least <code>1/(1 + 1/x)</code>. Using this modified version of Lemma 4.6, one can modify the proof of Theorem 4.7 to show that as long as <code>x ≥ 3n - 1</code>, the change in expectance from moving an item is at least <code>1/(3m)</code>. The value of <code>x</code> used in this implementation is <code>x = an</code>, where the keyword argument <code>a</code> is set to <code>3</code> by default (i.e., <code>x = 3n</code>). If <code>a</code> is set so that <code>x &lt; 3n - 1</code> a warning will be given. The warning can be turned off by setting <code>x_warn</code> to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/algorithms.jl#L590-L611">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_gmt18-Tuple{Additive}" href="#Allocations.alloc_gmt18-Tuple{Additive}"><code>Allocations.alloc_gmt18</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_gmt18(V)</code></pre><p>The 2/3-approximate MMS allocation algorithm described by Garg, McGlaughlin and Taki in their 2018 paper <a href="https://doi.org/10.4230/OASICS.SOSA.2019.20">Approximating Maximin Share Allocations</a>. The algorithm finds a 2/3-approximate MMS allocation for an instance with additive valuations. The algorithm works by performing a set of reductions to simplify the instance, limiting the maximum value of a good and the number of high-valued goods. The algorithm then uses bag-filling to allocate the remaining goods to the remaining agents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/algorithms.jl#L707-L718">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_half_mms" href="#Allocations.alloc_half_mms"><code>Allocations.alloc_half_mms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alloc_half_mms(V::Additive, C::Counts)</code></pre><p>Find a 1/2-approximate MMS allocation that obeys the constraints imposed by <code>C</code>. The allocation is found using <code>alloc_hh22_1</code>. See <a href="#Allocations.alloc_hh22_1-Tuple{Additive, Counts}"><code>alloc_hh22_1</code></a> for a detailed description of how the method works.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/algorithms.jl#L771-L777">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_hh22_1-Tuple{Additive, Counts}" href="#Allocations.alloc_hh22_1-Tuple{Additive, Counts}"><code>Allocations.alloc_hh22_1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_hh22_1(V::Additive, C::Counts; α=0.5)</code></pre><p>The 1/2-approximate MMS allocation under cardinality constraints algorithm (Algorithm 3) described by Hummel and Hetland in their <a href="https://doi.org/10.1007/978-3-031-20614-6_11">Maximin Shares Under Cardinality Constraints</a> (2022). First the instance is reduced to an ordered normalized instance where each good is worth less than 1/2. While there are more than one agent remaining, the algorithm creates a bundle with the <span>$⌊|\text{category}|/n⌋$</span> lowest-valued items in each category. Repeatedly, it converts each of these to the highest-valued remaining item in the category until it either runs out of items to convert or an agent values the bundle at least 1/2. If the procedure runs out of items to convert, it adds the highest-valued remaining item in each category, in order, to get <span>$⌈|\text{category}|/n⌉$</span> items from each category.  After each such item is added, the value is again checked for each agent. Since the instance was ordered normalized and without items worth 1/2 or more, the bundle created will always be worth more than 1/2 to one of the remaining agents before the procedure runs out of items to add to it or convert from low- to high-valued.</p><p>Another approximation ratio, <code>α</code>, can be supplied. If <code>α ≤ 0.5</code> the algorithm is guaranteed to succeed. Otherwise, the method will try to find an allocation with an approximation ratio of <code>α</code>, but may fail. In the latter case, the results will indicate a failure by setting <code>res.fail</code> to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/algorithms.jl#L4-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_rand-Tuple{Any, Conflicts}" href="#Allocations.alloc_rand-Tuple{Any, Conflicts}"><code>Allocations.alloc_rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_rand(V, C::Conflicts)</code></pre><p>Allocate items to agents randomly, respecting the item conflicts. Uses the <a href="https://doi.org/10.1007/978-3-540-70575-8_26">randomized coloring procedure with symmetry-breaking</a> of Pemmaraju and Srinivasan, which works as follows:</p><ol><li>Give the items random priorities, corresponding to a permutation selected uniformly at ramdom.</li><li>Tentatively allocate each item randomly to an agent, without concern for the item conflicts.</li><li>If an agent has received conflicting items, it keeps the highest-priority item (i.e., earliest in the permutation), and the others are reallocated arbitrarily.</li></ol><p>This final arbitrary reallocation is also performed randomly in this implementation, by going through the items in random order, allocating each to a randomly selected agent among those able to receive it.</p><p>The valuation profile <code>V</code> is not used, other than to determine the number of agents and items.</p><p>For this algorithm to function properly, the maximum degree of the conflict graph should be strictly less than the number of agents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/algorithms.jl#L134-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_rand-Tuple{Any}" href="#Allocations.alloc_rand-Tuple{Any}"><code>Allocations.alloc_rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_rand(V)</code></pre><p>A straightforward lottery that allocates the items randomly to the agents. For each item, its agent is selected uniformly at random. The valuation profile <code>V</code> is not used, other than to determine the number of agents and items. The return value is a named tuple with the field <code>alloc</code> (the <code>Allocation</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/algorithms.jl#L103-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_rand-Tuple{Int64, Int64, Conflicts}" href="#Allocations.alloc_rand-Tuple{Int64, Int64, Conflicts}"><code>Allocations.alloc_rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_rand(n::Int, m::Int, C::Conflicts)</code></pre><p>Same as <code>alloc_rand(V, C)</code>, for <code>n</code> agents and <code>m</code> items.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/algorithms.jl#L163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_rand-Tuple{Int64, Int64}" href="#Allocations.alloc_rand-Tuple{Int64, Int64}"><code>Allocations.alloc_rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_rand(n::Int, m::Int)</code></pre><p>Same as <code>alloc_rand(V)</code>, for <code>n</code> agents and <code>m</code> items.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/algorithms.jl#L114-L118">source</a></section></article><h3 id="Reductions"><a class="docs-heading-anchor" href="#Reductions">Reductions</a><a id="Reductions-1"></a><a class="docs-heading-anchor-permalink" href="#Reductions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.order-Tuple{Additive, Counts}" href="#Allocations.order-Tuple{Additive, Counts}"><code>Allocations.order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">order(V::Additive, C::Counts)</code></pre><p>Create an ordered instance for the given weights and categories. The items are reorded such that each category has a continous range of indices for its items. Returns a reduction, with a transformation that converts an allocation to one in the original instance where each agent gets at least the same value as in the ordered instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/reductions.jl#L319-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.order-Tuple{Additive}" href="#Allocations.order-Tuple{Additive}"><code>Allocations.order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">order(V::Additive)</code></pre><p>Create an ordered instance for the given weights. The weights are reordered for each agent such that item 1 is worth the most and item m is worth the least. Returns new additive valuations and a function to convert an allocation in the ordered instance into one for the original instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/reductions.jl#L282-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.reduceutil-Tuple{Profile, Vararg{Pair}}" href="#Allocations.reduceutil-Tuple{Profile, Vararg{Pair}}"><code>Allocations.reduceutil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduceutil(V::Profile, assignments::Pair...)</code></pre><p>Utility function that given valuations and a collection of assignments of bundles to agents (<code>i =&gt; B</code>), creates a reduced instance, translation tables from the reduced instance and a function to convert an allocation in the reduced instance to one in the original instance – including the given assignements. The function returns a <code>Reduction</code> object without any constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/reductions.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.reducevaluation-Tuple{Additive, Any, Any}" href="#Allocations.reducevaluation-Tuple{Additive, Any, Any}"><code>Allocations.reducevaluation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reducevaluation(V::Additive, λi, λg)</code></pre><p>Utility function that given additive valuations prior to a reduction and translation tables for the reduction, returns new additive valuations for the reduced instance. The new valuations are as prior to the reduction, except for missing items/agents and changes in item/agent numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/reductions.jl#L38-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.reducevaluation-Tuple{Submodular, Any, Any}" href="#Allocations.reducevaluation-Tuple{Submodular, Any, Any}"><code>Allocations.reducevaluation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reducevaluation(V::Submodular, λi, λg)</code></pre><p>Utility function that given submodular valuations prior to a reduction and translation tables for the reduction, returns new submodular valuations for the reduced instance. The new valuations are as prior to the reduction, except for missing items/agents and changes in item/agent numbers. That is, the new valuation functions work by translating the item numbers to what they would be prior to the reduction and calling the valuation function of the agent prior to the reduction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/reductions.jl#L49-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.revert-NTuple{4, Any}" href="#Allocations.revert-NTuple{4, Any}"><code>Allocations.revert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">revert(λi, λg, assignments, A)</code></pre><p>Convert an allocation for a reduced instance to one for the original instance, including giving the removed bundles to the removed agents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/reductions.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.revert-Tuple{Additive, Any}" href="#Allocations.revert-Tuple{Additive, Any}"><code>Allocations.revert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">revert(V::Additive, A)</code></pre><p>Convert an allocation for the ordered instance to one for the original instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/reductions.jl#L296-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.revert-Tuple{Additive, Counts, Counts, Any}" href="#Allocations.revert-Tuple{Additive, Counts, Counts, Any}"><code>Allocations.revert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">revert(V::Additive, C::Counts, C′::Counts, A)</code></pre><p>Convert an allocation for the ordered instance (<code>C′</code>) to one for the original instance <code>(V, C)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/reductions.jl#L349-L354">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reduce-Tuple{Additive, Counts{OrderedCategory}, Any, Any}" href="#Base.reduce-Tuple{Additive, Counts{OrderedCategory}, Any, Any}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(V::Additive, C::Counts{OrderedCategory}, i, B)</code></pre><p>Reduce the instance given by the pair (V, C) to a new instance by giving the supplied agent, <code>i</code>, the supplied bundle, <code>B</code>. Returns a reduction, where the transformation, in addition to converting the allocation to one for the original instance, allocates <code>B</code> to <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/reductions.jl#L77-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reduce-Tuple{Additive, Counts{OrderedCategory}, Real}" href="#Base.reduce-Tuple{Additive, Counts{OrderedCategory}, Real}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(V::Additive, C::Counts{OrderedCategory}, α)</code></pre><p>Reduce an ordered instance by normalizing the values and giving any agent that value an individual item greater than or equal to α the item and any low value items required to reduce to a valid instance. This reduction is performed recursively until no more such items exist. The reduction does not decrease the MMS guarantee of any remaining agents and all agents that are allocated a bundle in the reduction is guaranteed to value their bundle at least α of their MMS guarantee.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/reductions.jl#L212-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reduce-Tuple{Additive, Real}" href="#Base.reduce-Tuple{Additive, Real}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(V::Additive, α::Real; greedy::Bool=true)</code></pre><p>Reduce an ordered instance by normalizing the values and giving any agent that value an individual item greater than or equal to α the item.  This reduction is performed recursively until no more such items exist. The reduction does not decrease the MMS guarantee of any remaining agents and all agents that are allocated a bundle in the reduction is guaranteed to value their bundle at least α of their MMS guarantee. The agent-item pairs are either selected greedily or by finding a maximum matching between agents and such items.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/reductions.jl#L167-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reduce-Tuple{Additive, Vararg{Function}}" href="#Base.reduce-Tuple{Additive, Vararg{Function}}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(V::Additive, F::Function...)</code></pre><p>Reduce an instance V by repeatedly applying the functions f ∈ F to find bundles to be allocated. The functions in F are expected to return either a pair, <code>(i, B)</code>, consisting of an agent <code>i</code> and the bundle <code>B</code> to be assigned to agent <code>i</code>, or the value <code>nothing</code> if the function couldn&#39;t find a valid bundle-agent-pair. The functions are called in prioritized order and the instance is reduced and normalized between each invocation. The functions are invoked with the valuation matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/reductions.jl#L134-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reduce-Tuple{Profile, Real}" href="#Base.reduce-Tuple{Profile, Real}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(V::Profile, α::Real)</code></pre><p>Produce a reduced instance by giving an item to any agent that values it at <code>α</code> or more. This reduction is performed repeatedly, until no such item exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/reductions.jl#L256-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reduce-Tuple{Profile, Vararg{Pair}}" href="#Base.reduce-Tuple{Profile, Vararg{Pair}}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(V::Valuation, assignment::Pair...)</code></pre><p>Reduce the instance given to a new instance where the involved agents and bundles in the assignments are removed. Returns new valuations and a function that turns an allocation in the reduced instance into one for the original instance, including giving the supplied agent the supplied bundle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/reductions.jl#L66-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reduce-Tuple{Submodular, Any, Any}" href="#Base.reduce-Tuple{Submodular, Any, Any}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(V::Submodular, i, B)</code></pre><p>Reduce the instance given by <code>V</code> to a new instance by giving the specified bundle, <code>B</code>, to agent <code>i</code>. Returns a reduction, where the transformation, in addition to converting the allocation to one for the original instance, allocates <code>B</code> to <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/reductions.jl#L101-L108">source</a></section></article><h2 id="MIP-based"><a class="docs-heading-anchor" href="#MIP-based">MIP-based allocation</a><a id="MIP-based-1"></a><a class="docs-heading-anchor-permalink" href="#MIP-based" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_ef1-Tuple{Any, Any}" href="#Allocations.alloc_ef1-Tuple{Any, Any}"><code>Allocations.alloc_ef1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_ef1(V, C; solver=conf.MIP_SOLVER, kwds...)</code></pre><p>Create an <code>Allocation</code> that is envy-free up to one item (EF1), based on the valuation profile <code>V</code>, possibly subject to the constraints given by the <code>Constraint</code> object <code>C</code>. The solution is found using a straightforward mixed-integer program, and is most suitable for constraints where no specialized algorithm exists. For example, without constraints, a straightforward round robin picking sequence yields EF1, and a similar strategy works for cardinality constraints. (It is still possible to use this function without constraints, by explicitly supplying <code>nothing</code> for the constraint argument <code>C</code>.) The return value is a named tuple with the fields <code>alloc</code> (the <code>Allocation</code>) and <code>model</code> (the JuMP model used in the computation).</p><p>Lower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments <code>min_bundle</code>, <code>max_bundle</code>, <code>min_owners</code> and <code>max_owners</code>, the latter two of which default to <code>1</code>. If one of these is <code>nothing</code>, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.</p><p>Note that for some constraints, there may not <em>be</em> an EF1 allocation, in which case the function will fail with an exception.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/mip.jl#L448-L466">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_efx" href="#Allocations.alloc_efx"><code>Allocations.alloc_efx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alloc_efx(V[, C]; solver=conf.MIP_SOLVER, kwds...)</code></pre><p>Create an <code>Allocation</code> that is envy-free up to any item (EFX), based on the valuation profile <code>V</code>, possibly subject to the constraints given by the <code>Constraint</code> object <code>C</code>. The solution is found using a straightforward mixed-integer program. The return value is a named tuple with the fields <code>alloc</code> (the <code>Allocation</code>) and <code>model</code> (the JuMP model used in the computation).</p><p>Lower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments <code>min_bundle</code>, <code>max_bundle</code>, <code>min_owners</code> and <code>max_owners</code>, the latter two of which default to <code>1</code>. If one of these is <code>nothing</code>, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.</p><p>Note that while some constraints may prevent an exact EFX allocation, it is currently (Mar 2021) an open question whether EFX always exists in the unconstrained case (see, e.g., <a href="https://arxiv.org/abs/2103.01628">Improving EFX Guarantees through Rainbow Cycle Number</a> by Chaudhury et al.).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/mip.jl#L478-L493">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_ggi" href="#Allocations.alloc_ggi"><code>Allocations.alloc_ggi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alloc_ggi(V[, C]; wt=wt_gini, solver=conf.MIP_SOLVER, kwds...)</code></pre><p>Maximizes a generalized Gini index (GGI), also known as a generalized Gini social-evaluation functions. The function being maximized is an ordered weighted average (OWA) of agent utilities, utilities, where the weight is based on utility rank <code>i</code>, from the least happy (<code>1</code>) to the most happy (<code>n</code>), parameterized by the function <code>wt(i, n)</code>. It is generally assumed that the weights are nondecreasing in <code>i</code>. Note that there is no need to use normalized weights (i.e., to produce a weighted average, despite the term OWA), as is often the case when such measures are used to measure <em>in</em>equality (e.g., by subtracting the OWA from an ordinary average, cf. <a href="https://doi.org/10.1016/0165-4896(81)90018-4">Generalized gini inequality indices</a> by John A. Weymark).</p><p>The default <code>wt_gini</code> gives the (non-normalized) weights of the original Gini social-evaluation. Two other notable cases for <code>wt</code> are <code>(i, _) -&gt; i == 1</code>, which yields a maximin allocation, and <code>(i, _) -&gt; 1</code>, which yields a purely utilitarian allocation (with no consideration for fairness). The solution method used is based on that of Lesca and Perny (linear formulation <span>$\Pi&#39;_W$</span>) in their paper 2010 paper <a href="https://doi.org/10.3233/978-1-60750-606-5-393">“LP Solvable Models for Multiagent Fair Allocation Problems”</a>. The return value is a named tuple with the fields <code>alloc</code> (the <code>Allocation</code> that has been produced) and <code>model</code> (the JuMP model used in the computation).</p><p>Lower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments <code>min_bundle</code>, <code>max_bundle</code>, <code>min_owners</code> and <code>max_owners</code>, the latter two of which default to <code>1</code>. If one of these is <code>nothing</code>, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.</p><p>In the original inequality measures, the mean agent utility is included as a normalizing term, which is harmless for the case of identical valuations functions (and when looking at, say, the distribution of incomes), but when valuations differ, this mean will vary with the allocations. As pointed out by Lesca and Perny, such a measure is not monotone with Pareto dominance – the optimization will tend to drive the mean utility <em>down</em>. Therefore only the term measuring (in)equality (i.e., the ordered weighted sum of agent utilities) is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/mip.jl#L853-L887">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_lmm" href="#Allocations.alloc_lmm"><code>Allocations.alloc_lmm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alloc_lmm(V[, C]; solver=conf.MIP_SOLVER, kwds...)</code></pre><p>Create a lexicographic maximin (leximin) <code>Allocation</code>, i.e., one where the lowest bundle value is maximized, and subject to that, the second lowest is maximized, etc. The return value is a named tuple with fields <code>alloc</code> (the <code>Allocation</code>) and <code>model</code> (the JuMP model used in the computation).</p><p>The method used for leximin optimization is that of Ogryczak and Śliwiński (<a href="https://doi.org/10.1007/11751595_85">&quot;On Direct Methods for Lexicographic Min-Max Optimization&quot;</a>, 2006).</p><p>Lower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments <code>min_bundle</code>, <code>max_bundle</code>, <code>min_owners</code> and <code>max_owners</code>, the latter two of which default to <code>1</code>. If one of these is <code>nothing</code>, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/mip.jl#L646-L659">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_mm" href="#Allocations.alloc_mm"><code>Allocations.alloc_mm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alloc_mm(V[, C]; cutoff=nothing, ignored_agents=[],
    solver=conf.MIP_SOLVER, kwds...)</code></pre><p>Create an egalitarian or maximin <code>Allocation</code>, i.e., one where the minimum bundle value is maximized. The <code>cutoff</code>, if any, is a level at which we are satisfied, i.e., any allocation where all agents attain this value is acceptable. The return value is a named tuple with fields <code>alloc</code> (the <code>Allocation</code>), <code>mm</code> (the lowest agent utility) and <code>model</code> (the JuMP model used in the computation).</p><p>The <code>ignored_agents</code> argument indicates agents that should be ignored when maximizing the minimum. These agents may still receive items, and will participate in forming a feasible allocation (possibly with respect to some constraint <code>C</code>); they are only ignored in the objective.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Most users will probably not need <code>ignored_agents</code>. Its primary use is as part of <code>alloc_mms</code>, for ignoring agents with an MMS of zero, whose α is unbounded.</p></div></div><p>Lower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments <code>min_bundle</code>, <code>max_bundle</code>, <code>min_owners</code> and <code>max_owners</code>, the latter two of which default to <code>1</code>. If one of these is <code>nothing</code>, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/mip.jl#L610-L633">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_mms" href="#Allocations.alloc_mms"><code>Allocations.alloc_mms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alloc_mms(V[, C]; cutoff=false, solver=conf.MIP_SOLVER,
          mms_kwds=(), kwds...)</code></pre><p>Find an MMS allocation, i.e., one that satisfies the <em>maximin share guarantee</em>, where each agent gets a bundle it weakly prefers to its maximin share (introduced by Budish, in his 2011 paper <a href="https://doi.org/10.1086/664613">The Combinatorial Assignment Problem: Approximate Competitive Equilibrium from Equal Incomes</a>). The return value is a named tuple with fields <code>alloc</code> (the <code>Allocation</code>), <code>mmss</code>, the individual MMS values for the instance, <code>alpha</code>, the lowest fraction of MMS that any agent achieves (is at least 1 exactly when the allocation is MMS), <code>model</code> (the JuMP model used in computing <code>alpha</code>) and <code>mms_models</code> (the JuMP models used to compute the individual maximin shares). If <code>cutoff</code> is set to <code>true</code>, this fraction is capped at 1.</p><p>If all agents have an MMS of zero, <code>alpha</code> will be unbounded, represented by the value <code>Inf</code>. This is the case even if one or more agents get a value of <code>0</code>.</p><p>Lower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments <code>min_bundle</code>, <code>max_bundle</code>, <code>min_owners</code> and <code>max_owners</code>, the latter two of which default to <code>1</code>. If one of these is <code>nothing</code>, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.</p><p>When finding an MMS partition for each individual agent, the constraint and options act a little differently than when finding the actual allocation. If an asymmetric <code>Constraint</code> <code>C</code> is supplied (i.e., one that is different for the different agents), agent <code>i</code>&#39;s version is enforced on every bundle to determine which partitions are feasible.</p><p>The same holds for <code>min_bundle</code> and <code>max_bundle</code>. Apart from those two, the keywords <code>kwds</code> are also used for the MMS partitions.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>In some cases, using asymmetric constraints might lead to a situation where a feasible allocation exists, but for some agent, an MMS partition does not. Then the agent&#39;s maximin share is undefined! One way around this is to relax the definition a bit, and to permit charity when finding the MMS partitions. The agent will still try to maximize the mininum value of any bundle in this partition, but is not required to allocate every object. This can be achieved as follows:</p><pre><code class="language-julia hljs">alloc_mms(V, C, mms_kwds=(min_owner=0,))</code></pre><p>You should verify that the strategy makes sense for your application, however! In some cases, it might not be necessary, and would just needlessly inflate maximin shares. Also, it is only guaranteed to work for constraints where an empty bundle is feasible; it might fail for <a href="#Allocations.Required"><code>Required</code></a>, for example. Indeed, for some constraints, one could argue that it might not be advisable to use the MMS criterion to begin with.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/mip.jl#L745-L796">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_mnw" href="#Allocations.alloc_mnw"><code>Allocations.alloc_mnw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alloc_mnw(V[, C]; mnw_warn=false, solver=conf.MIP_SOLVER, kwds...)</code></pre><p>Create an <code>Allocation</code> attaining maximum Nash welfare (MNW), based on the valuation profile <code>V</code>, possibly subject to the constraints given by the <code>Constraint</code> object <code>C</code>. The solution is found using the approach of Caragiannis et al. in their 2019 paper <a href="https://doi.org/10.1145/3355902">The Unreasonable Fairness of Maximum Nash Welfare</a>, with two minor modifications:</p><ol><li><p>Rather than hard-coding a maximum valuation (arising from the assumption that the values of each agent sum to 1000), this maximum is extracted from <code>V</code>; and</p></li><li><p>Extra constraints are permitted (through the object <code>C</code>), possibly lowering the attainable MNW.</p></li></ol><p>Because of how the integer program is constructed, it may be affected by precision effects, where a high number of agents can make it impossible to guarantee Pareto optimalty (PO), EF1 or MNW. If the precision is too low, the appropriate warning will be issued, but the computation is not halted. Note that these warnings are quite conservative (see note below). This is particularly true of the one for MNW, which is disabled by default, in part because of its sensitivity, and in part because it will generally be useful to find solutions that satisfy PO and EF1, even if it may not be exactly MNW. The MNW warning can be enabled by setting the <code>mnw_warn</code> keyword to <code>true</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The warnings are based on the lower bounds described by Caragiannis et al. On the one hand, the bound is only used to test whether current floating-point precision is sufficient; any tolerance or gap used by the solver is not used, which might in principle mean that false negatives are possible. On the other hand, these bounds, especially the one for exact MNW, may in practice be quite loose, with small variations in agent utilities leading to large changes in objective value, unless the changes are finely tuned to cancel out.</p></div></div><p>The return value is a named tuple with fields <code>alloc</code> (the <code>Allocation</code>), <code>mnw</code> (the achieved Nash welfare for the agents with nonzero utility), <code>mnw_prec</code> (whether or not there was enough precision to satisfy the lower bound guaranteeing exact MNW) and <code>model</code> (the JuMP model used in the computation).</p><p>Lower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments <code>min_bundle</code>, <code>max_bundle</code>, <code>min_owners</code> and <code>max_owners</code>, the latter two of which default to <code>1</code>. If one of these is <code>nothing</code>, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/mip.jl#L517-L560">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.alloc_mnw_ef1-Tuple{Any, Any}" href="#Allocations.alloc_mnw_ef1-Tuple{Any, Any}"><code>Allocations.alloc_mnw_ef1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_mnw_ef1(V, C; mnw_warn=true, solver=conf.MIP_SOLVER, kwds...)</code></pre><p>Equivalent to <code>alloc_mnw</code>, except that EF1 is enforced. Without any added constraints, MNW implies EF1, so this function is not needed in that case. Therefore the argument <code>C</code> is not optional.</p><p>Lower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments <code>min_bundle</code>, <code>max_bundle</code>, <code>min_owners</code> and <code>max_owners</code>, the latter two of which default to <code>1</code>. If one of these is <code>nothing</code>, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/mip.jl#L573-L581">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.mms" href="#Allocations.mms"><code>Allocations.mms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mms(V::Additive, i[, C]; solver=conf.MIP_SOLVER, kwds...)</code></pre><p>Determine the maximin share of agent <code>i</code>, i.e., the bundle value she is guaranteed to attain if she partitions the items and the other agents choose their bundles. Useful, e.g., as a point of reference when determining the empirical approximation ratios of approximate MMS allocation algorithms. Also used as a subroutine in <code>alloc_mms</code>. The return value is a named tuple with the fields <code>mms</code> (the maximin share of agent <code>i</code>) and <code>model</code> (the JuMP model used in the computation).</p><p>Lower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments <code>min_bundle</code>, <code>max_bundle</code>, <code>min_owners</code> and <code>max_owners</code>, the latter two of which default to <code>1</code>. If one of these is <code>nothing</code>, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.</p><p>If a constraint <code>C</code> is supplied, and this is asymmetric (i.e., different for the different agents), agent <code>i</code>&#39;s version is enforced on every bundle to determine which partitions are feasible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/mip.jl#L687-L703">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.mms_alpha-Tuple{Any, Any, Any}" href="#Allocations.mms_alpha-Tuple{Any, Any, Any}"><code>Allocations.mms_alpha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mms_alpha(V, A, mmss)</code></pre><p>Utility function to find the fraction of the maximin share guarantee attained by the allocation <code>A</code>, under the valuation profile <code>V</code>, where <code>mmss[i]</code> is the MMS of agent <code>i</code>. This makes it possible, for example, to use the <code>mmss</code> field from the result of <code>alloc_mms</code> to find the MMS approximation provided by an allocation constructed by other means. For example:</p><pre><code class="nohighlight hljs">mmss = alloc_mms(V).mmss
A = alloc_rand(V).alloc
alpha = mms_alpha(V, A, mmss)</code></pre><p>If all agents have an MMS of zero, <code>alpha</code> will be unbounded, represented by the value <code>Inf</code>. This is the case even if one or more agents get a value of <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/mip.jl#L721-L736">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.wt_gini-Tuple{Any, Any}" href="#Allocations.wt_gini-Tuple{Any, Any}"><code>Allocations.wt_gini</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wt_gini(i, n)</code></pre><p>The (unnormalized) weights used in the ordered weighted average in the Gini social-evaluation function, where the utility of the <code>i</code>th agent, ordered by increasing utility, is given weight <span>$2(n - i) + 1$</span>. (The normalized weights yielding the original Gini social-evaluation function are divided by <span>$n^2$</span>, but this makes no difference to the optimization problem.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/mip.jl#L841-L849">source</a></section></article><h2 id="Instance-generation"><a class="docs-heading-anchor" href="#Instance-generation">Instance generation</a><a id="Instance-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Instance-generation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.rand_additive-Tuple{}" href="#Allocations.rand_additive-Tuple{}"><code>Allocations.rand_additive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_additive(; n=2:10, m=n-&gt;2n:4n, v=(n, m)-&gt;Uniform(), rng=default_rng())
rand_profile(; n=2:10, m=n-&gt;2n:4n, v=(n, m)-&gt;Uniform(), rng=default_rng())</code></pre><p>Generate a random additive valuation profile (an <code>Additive</code> object) with the number of agents and items, agents and values chosen using <code>rand</code> with the given values as the first argument. Here <code>n</code> is used directly, while <code>m</code> should be a <em>function of the number of agents</em>, which returns an argument for <code>rand</code>. Similarly, <code>v</code> should be a function of both the number of agents and items.</p><p>The defaults for <code>n</code> and <code>m</code> are taken from <a href="https://arxiv.org/abs/2104.06280">Hummel and Hetland</a>, who based them on based on real-world data from <a href="https://doi.org/10.1145/3355902">Caragiannis et al.</a>, with <code>n</code> at most 10, and the average <code>m/n</code> approximately 3.</p><p>The distribution for the values can be univariate, in which case it is used independently for each value. For example, to generate Gaussian valuations, with the <a href="https://github.com/JuliaStats/Distributions.jl"><code>Distributions</code></a> package, use <code>v=(n, m)-&gt;Normal()</code>.</p><p>However, it can also be multivariate, in which case each sample should be a vector of the same length as the number of items, representing the valuation function of a single agent. For example, to get a <code>Dirichlet</code> distribution, where an agent&#39;s values sum to <code>1</code>, you could use <code>v=(n, m)-&gt;Dirichlet(m, 2)</code>.</p><p>It is also possible to use a matrix-variate distribution, such as a matrix normal distribution, where each sample should then be an <code>m</code> by <code>n</code> matrix, with each column representing the valuation function of a single agent.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Note that the matrix samples should be the <em>transpose</em> of the ones used in the resulting profile. This is to maintain consistency with the multivariate distributions, which produce column vectors.</p></div></div><p><code>rand_profile</code> is an alias for <code>rand_additive</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/data.jl#L9-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.rand_conflicts_ba02-Tuple{Any}" href="#Allocations.rand_conflicts_ba02-Tuple{Any}"><code>Allocations.rand_conflicts_ba02</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_conflicts_ba02(m; k=1:m, rng=default_rng())
rand_conflicts_ba02(V::Profile; ...)</code></pre><p>Generate a random <code>Conflicts</code> contraint, whose underlying graph is constructed according to the <a href="https://arxiv.org/abs/cond-mat/0106096">Barabási–Albert model</a>. The keyword argument <code>k</code> specifies the possible values for the corresponding parameter <span>$k$</span>, which is generated using <code>rand</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/data.jl#L101-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.rand_conflicts_er59-Tuple{Any}" href="#Allocations.rand_conflicts_er59-Tuple{Any}"><code>Allocations.rand_conflicts_er59</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_conflicts_er59(m, p=Uniform(), rng=default_rng())
rand_conflicts_er59(V::Profile; ...)
rand_conflicts(m; ...)
rand_conflicts(m::Profile; ...)</code></pre><p>Generate a random <code>Conflicts</code> contraint, whose underlying graph is constructed according to the <a href="https://doi.org/10.5486%2FPMD.1959.6.3-4.12">Erdős–Rényi model</a>. The keyword argument <code>p</code> specifies the possible values for the corresponding parameter <span>$p$</span>, which is generated using <code>rand</code>.</p><p><code>rand_conflicts</code> is an alias for <code>rand_conflicts_er59</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/data.jl#L78-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.rand_conflicts_ws98-Tuple{Any}" href="#Allocations.rand_conflicts_ws98-Tuple{Any}"><code>Allocations.rand_conflicts_ws98</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_conflicts_ws98(m; k=2:2:div(m, 2), β=Uniform(), rng=default_rng())
rand_conflicts_ws98(V::Profile; ...)</code></pre><p>Generate a random <code>Conflicts</code> contraint, whose underlying graph is constructed according to the <a href="https://doi.org/10.1038/30918">Watts–Strogatz model</a>. The keyword arguments <code>k</code> and <code>β</code> specify the possible values for the corresponding parameters <span>$k$</span> and <span>$\beta$</span>, which are generated using <code>rand</code>. The defaults are taken from <a href="https://arxiv.org/abs/2104.06280">Hummel and Hetland</a>. Note that the parameter <span>$k$</span> should be an even number, which Watts and Strogatz assume to be much smaller than <span>$m$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/data.jl#L58-L69">source</a></section></article><h2 id="Configuration"><a class="docs-heading-anchor" href="#Configuration">Configuration</a><a id="Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Allocations.conf" href="#Allocations.conf"><code>Allocations.conf</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">conf</code></pre><p>A struct with fields for global configuration of the <code>Allocations</code> module.</p><p><strong>Fields</strong></p><pre><code class="language-julia hljs">MIP_SOLVER::Any</code></pre><p>The (factory for the) JuMP optimizer to be used (by default) for mixed-integer programming. Initially set to <code>HiGHS.Optimizer</code>, with <code>log_to_console</code> set to <code>false</code>. This can be overridden either by setting <code>MIP_SOLVER</code> to another value (e.g., using the JuMP function <code>optimizer_with_attributes</code>) or by passing the solver directly to the appropriate allocation functions.</p><pre><code class="language-julia hljs">MIP_SUCCESS::Any</code></pre><p>Container of acceptable MIP statuses. By default, has the value <code>[MOI.OPTIMAL]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/6a2495a9c61085a4ec2cb6588c079d5662af7c09/src/conf.jl#L6-L29">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Allocations.jl</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Thursday 4 July 2024 12:39">Thursday 4 July 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
