<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Allocations</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Allocations</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Allocations.jl</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Basic-types"><span>Basic types</span></a></li><li><a class="tocitem" href="#Checks-and-measures"><span>Checks and measures</span></a></li><li><a class="tocitem" href="#Allocation-algorithms"><span>Allocation algorithms</span></a></li><li><a class="tocitem" href="#MIP-based-allocation"><span>MIP-based allocation</span></a></li><li><a class="tocitem" href="#Configuration"><span>Configuration</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mlhetland/Allocations.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p><strong>Function naming:</strong> Allocation functions that use a straightforward procedure, or simply use a solver to enforce some property, are named after that procedure or property (such as <code>alloc_rand</code> or <code>alloc_ef1</code>). For published algorithms, the package uses a naming scheme based on the original publication.</p><p>The root of the function name is <code>alloc_</code>, followed by a publication code:</p><ul><li>For a single-author paper, the first three letters of the author&#39;s last name are used;</li><li>for multi-author papers, the first letter of the first four authors are concatenated.</li><li>To this, the last two digits of the year are added.</li></ul><p>For example, the 2/3-MMS algorithm of Garg, McGlaughlin and Taki (2018) is implemented by <code>alloc_gmt18</code>.</p><ul><li><p>If the same code applies to multiple publications, they are distinguished by a suffix <code>a</code>, <code>b</code>, etc., after the year digits.</p></li><li><p>If a single publication discusses multiple algorithms, a number such as <code>_1</code>, <code>_2</code>, etc., is added. So, for example, the third algorithm described by Biswas and Barman (2018) is <code>alloc_bb18_3</code>.</p></li></ul><p>Some functions (such as <code>alloc_hh22_1</code>) are given generic names as aliases (in this case, <code>alloc_half_mms</code>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>These publication codes are similar to the <a href="https://en.wikipedia.org/wiki/Citation">authorship trigraphs used in some citation styles</a>. Specifically, they follow the conventions of <a href="http://tug.ctan.org/tex-archive/biblio/bibtex/base/alpha.bst"><code>alpha.bst</code></a>, except that an &quot;et al.&quot; character is not added when there are five or more authors.</p></div></div><h2 id="Basic-types"><a class="docs-heading-anchor" href="#Basic-types">Basic types</a><a id="Basic-types-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Allocations.Additive" href="#Allocations.Additive"><code>Allocations.Additive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Additive{T &lt;: AbstractMatrix} &lt;: Profile</code></pre><p>An additive valuation profile, representing how each agent values all possible bundles. Because of additivity, this is easily &quot;lifted&quot; from the values of individual items, by addition, with an empty bundle given a value of zero. By default, the profile is constructed from a real matrix <code>X</code>, supplied to the default constructor, where <code>X[i, g]</code> is agent <code>i</code>&#39;s value for item <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L374-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.Additive-Tuple{Any, Any}" href="#Allocations.Additive-Tuple{Any, Any}"><code>Allocations.Additive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Additive(n, m)</code></pre><p>Create an additive profile for <code>n</code> agents and <code>m</code> items where all values are set to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L388-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.Allocation" href="#Allocations.Allocation"><code>Allocations.Allocation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Allocation &lt;: Any</code></pre><p>A mapping <code>A</code> from agents <code>i</code> to their assigned bundles <code>bundle(A, i)</code>. Agents and items are represented as <code>Int</code>s, and bundles as <code>Set</code>s of <code>Int</code>s. The <code>Allocation</code> also maintains an inverse mapping, from items <code>g</code> to their set of owners, <code>owners(A, g)</code>. To keep these in sync, the bundles should be modified using <code>give!</code> and <code>deny!</code>, rather than altering the bundle sets directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L57-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.Allocation-Tuple{Int64, Int64}" href="#Allocations.Allocation-Tuple{Int64, Int64}"><code>Allocations.Allocation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Allocation(n::Int, m::Int)</code></pre><p>Construct an empty allocation with <code>n</code> agents and <code>m</code> items.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.Allocation-Tuple{Profile}" href="#Allocations.Allocation-Tuple{Profile}"><code>Allocations.Allocation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Allocation(V::Profile)</code></pre><p>Construct an empty allocation with a number of agents and items equal to that of the instance (i.e., profile) <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L295-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.Allocation-Tuple{}" href="#Allocations.Allocation-Tuple{}"><code>Allocations.Allocation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Allocation()</code></pre><p>Construct an empty allocation with zero agents and items.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.Category" href="#Allocations.Category"><code>Allocations.Category</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Category</code></pre><p>One of the categories in a <code>Counts</code> constraint, from which each agent can hold at most a given number of items. The category supports iteration (over its members), and the threshold is available through the <code>threshold</code> accessor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L521-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.Conflicts" href="#Allocations.Conflicts"><code>Allocations.Conflicts</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Conflicts{T &lt;: AbstractGraph} &lt;: Constraint</code></pre><p>A kind of constraint – or set of constraints – that indicates that certain items conflict, and thus cannot be allocated to the same agent. The constraints are represented as a <em>conflict graph</em> (<code>Graphs.AbstractGraph</code>), with items as nodes, and edges representing conflicts. The <code>Conflicts</code> type is just a wrapper for dispatch purposes, with the underlying graph available through the <code>graph</code> accessor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L631-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.Constraint" href="#Allocations.Constraint"><code>Allocations.Constraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Constraint &lt;: Any</code></pre><p>Abstract supertype of various kinds of constraints. An instance of the allocation problem is assumed to consist of a <code>Profile</code> object and at most one <code>Constraint</code> object, embodying any and all constraints placed on feasible solutions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L510-L517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.Counts" href="#Allocations.Counts"><code>Allocations.Counts</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Counts{T} &lt;: Constraint</code></pre><p>The <em>cardinality constraints</em> used by Biswas and Barman in their 2018 paper <a href="https://www.ijcai.org/proceedings/2018/13">Fair Division Under Cardinality Constraints</a>. This is a form of constraint consisting of several <code>Category</code> objects, available through indexing or iteration. Any agent may hold at most a given number of items from any given category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L602-L611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.Counts-Tuple{Vararg{Pair}}" href="#Allocations.Counts-Tuple{Vararg{Pair}}"><code>Allocations.Counts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Counts(args::Pair...)</code></pre><p>Create a <code>Counts</code> object where each pair <code>x =&gt; k</code> becomes a category with members <code>Set(x)</code> and threshold <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L617-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.OrderedCategory" href="#Allocations.OrderedCategory"><code>Allocations.OrderedCategory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct OrderedCategory</code></pre><p>Used in place of <code>Category</code> when handling an ordered instance. The instance is assumed to be such that items in the range <code>index:index + n_items - 1</code> belong to the given category, i.e., the items of a category occupy a contiguous range of integers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L547-L554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.Profile" href="#Allocations.Profile"><code>Allocations.Profile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract struct Profile &lt;: Any</code></pre><p>An abstract type representing an valuation profile. Which functions are used to query it depends on the kind of valuation functions it represents. Additive valuations act on individual objects, and simply sum those values over a bundle, but profiles with quite different kinds of queries are possible for valuations with other properties (see, e.g., <a href="https://dl.acm.org/doi/10.1145/3219166.3219238">Fair Allocation of Indivisible Goods: Improvements and Generalizations</a> by Ghodsi et al., 2018).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L280-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.Profile-Tuple{Matrix}" href="#Allocations.Profile-Tuple{Matrix}"><code>Allocations.Profile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Profile(X::Matrix)</code></pre><p>Alias for <code>Additive(X)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L397-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.Reduction" href="#Allocations.Reduction"><code>Allocations.Reduction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Reduction{S, T, U, V}</code></pre><p>A reduction from one instance of a fair allocation problem to another. Contains information about the profiles in the reduced instance, through an object of type <code>S</code>. There must exist functions <code>agents(s::S)</code> and <code>items(s::S)</code> that return iterators of, respectively, the agents and items in the reduced instance. The reduction can also contain information about the constraints in the reduced instance, through an object of type <code>T</code>.</p><p>In addition, the reduction contains two mappings (vectors), <code>λi</code> (of type <code>I</code>) and <code>λg</code> (of type <code>G</code>). Both types should be indexable (for <code>i ∈ agents(s)</code> and <code>g ∈ items(s)</code>, respectively). <code>λi[i]</code> and <code>λg[g]</code> should return the agent and item identifier in the original instance of, respectively, agent <code>i</code> and item <code>g</code> in the reduced instance.</p><p>The reduction also contains a function that can convert an allocation in the reduced instance to one in the original instance.</p><p>The default constructor is <code>Reduction(V, C, λi, λg, transform::Function)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L657-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.Reduction-NTuple{4, Any}" href="#Allocations.Reduction-NTuple{4, Any}"><code>Allocations.Reduction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Reduction(V, λi, λg, transform)</code></pre><p>A simplified constructor for when there are no constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L687-L691">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.Reduction-Tuple{Any, Any}" href="#Allocations.Reduction-Tuple{Any, Any}"><code>Allocations.Reduction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Reduction(V, C)</code></pre><p>A simplified constructor for when either no changes have been performed or changes only concern the profiles and/or constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L695-L700">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.Reduction-Tuple{Any}" href="#Allocations.Reduction-Tuple{Any}"><code>Allocations.Reduction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Reduction(V)</code></pre><p>A simplified constructor for when either no changes have been performed or changes only concern the profiles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L704-L709">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.Reduction-Tuple{Reduction, Any}" href="#Allocations.Reduction-Tuple{Reduction, Any}"><code>Allocations.Reduction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Reduction(R::Reduction, C)</code></pre><p>A simplified constructor to create a copy of a reduction with constraints attached.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L712-L717">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.Submodular" href="#Allocations.Submodular"><code>Allocations.Submodular</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Submodular &lt;: Profile</code></pre><p>A submodular valuation profile, representing how each agent values all possible bundles. The profile is constructed from a set of <code>n</code> submodular valuation functions, one per agent, as well as the number of items, <code>m</code>. The profile functions should, when supplied with a <code>Set</code> of items (a subset of <code>1:m</code>), return the value of that set of items to the given agent (i.e., acting as so-called <em>query oracles</em>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L483-L492">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.agent-Tuple{Reduction, Any}" href="#Allocations.agent-Tuple{Reduction, Any}"><code>Allocations.agent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">agent(R::Reduction, i)</code></pre><p>Converts the agent identifier <code>i</code> from the reduced instance to the agent identifier of the same agent in the original instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L745-L750">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.agents-Tuple{Any}" href="#Allocations.agents-Tuple{Any}"><code>Allocations.agents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">agents(X)</code></pre><p>Returns the set of agents associated with (e.g., profile or allocation) <code>X</code>), as an iterable of <code>Int</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.bundle-Tuple{Any, Any}" href="#Allocations.bundle-Tuple{Any, Any}"><code>Allocations.bundle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bundle(A, i)</code></pre><p>The set of items allocated to agent <code>i</code> in the allocation <code>A</code>. The returned <code>Set</code> should be treated as read-only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.ceil_n-Tuple{OrderedCategory, Any}" href="#Allocations.ceil_n-Tuple{OrderedCategory, Any}"><code>Allocations.ceil_n</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ceil_n(c::OrderedCategory, n)</code></pre><p>One <code>n</code>th of the number of items in the category, rounded up.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L584-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.chain-Tuple{Reduction, Reduction}" href="#Allocations.chain-Tuple{Reduction, Reduction}"><code>Allocations.chain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chain(R₁::Reduction, R₂::Reduction)</code></pre><p>Assumes that R₂ is a reduction of the reduced instance of R₁. Combines the two reductions, so that the original instance is the original instance of R₁ and the reduced instance is the reduced instance of R₂ (essentially diagram-order composition of the reductions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L763-L770">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.constraint-Tuple{Reduction}" href="#Allocations.constraint-Tuple{Reduction}"><code>Allocations.constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint(R::Reduction)</code></pre><p>Returns the constraint object for the reduced instance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L728-L732">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.deny!-Tuple{Any, Any, Any}" href="#Allocations.deny!-Tuple{Any, Any, Any}"><code>Allocations.deny!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deny!(A, i, g)</code></pre><p>Deny agent <code>i</code> the object <code>g</code>, which it has previously been given, in the allocation <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L226-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.fill_even!-Tuple{Any}" href="#Allocations.fill_even!-Tuple{Any}"><code>Allocations.fill_even!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fill_even!(A)</code></pre><p>Fill out the allocation by distributing the unallocated items evenly, by repeatedly giving the next unallocated item to the agent with the fewest items (ties broken arbitrarily).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L239-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.fill_random!-Tuple{Any}" href="#Allocations.fill_random!-Tuple{Any}"><code>Allocations.fill_random!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fill_random!(A)</code></pre><p>Fill out the allocation by distributing the unallocated items randomly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L262-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.floor_n-Tuple{OrderedCategory, Any}" href="#Allocations.floor_n-Tuple{OrderedCategory, Any}"><code>Allocations.floor_n</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floor_n(c::OrderedCategory, n)</code></pre><p>One <code>n</code>th of the number of items in the category, rounded down.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L576-L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.give!-Tuple{Any, Any, Any}" href="#Allocations.give!-Tuple{Any, Any, Any}"><code>Allocations.give!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">give!(A, i, B)</code></pre><p>Give agent <code>i</code> the bundle <code>B</code> in the <code>Allocation</code> <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L212-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.give!-Tuple{Any, Any, Int64}" href="#Allocations.give!-Tuple{Any, Any, Int64}"><code>Allocations.give!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">give!(A, i, g::Int)</code></pre><p>Give agent <code>i</code> the object <code>g</code> in the <code>Allocation</code> <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L200-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.graph-Tuple{Conflicts}" href="#Allocations.graph-Tuple{Conflicts}"><code>Allocations.graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">graph(C::Conflicts)</code></pre><p>Return the conflict graph wrapped by a <code>Conflicts</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L646-L650">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.isintegral" href="#Allocations.isintegral"><code>Allocations.isintegral</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isintegral(V::Profile)</code></pre><p>Test whether every value provided by <code>V</code> is an integer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L347-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.isnonnegative" href="#Allocations.isnonnegative"><code>Allocations.isnonnegative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isnonnegative(V::Profile)</code></pre><p>Test whether every value provided by <code>V</code> is nonnegative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L355-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.item-Tuple{Reduction, Any}" href="#Allocations.item-Tuple{Reduction, Any}"><code>Allocations.item</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">item(R::Reduction, g)</code></pre><p>Converts the item identifier <code>g</code> from the reduced instance to the item identifier of the same item in the original instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L754-L759">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.items-Tuple{Any}" href="#Allocations.items-Tuple{Any}"><code>Allocations.items</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">items(X)</code></pre><p>Returns the set of items associated with (e.g., profile or allocation) <code>X</code>, as an iterable of <code>Int</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.matrix-Tuple{Additive}" href="#Allocations.matrix-Tuple{Additive}"><code>Allocations.matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix(V::Additive)</code></pre><p>Return the underlying valuation matrix of <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L466-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.matrix-Tuple{Profile}" href="#Allocations.matrix-Tuple{Profile}"><code>Allocations.matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix(V::Profile)</code></pre><p>Return a matrix <code>X</code> where <code>X[i, g]</code> is <code>value(V, i, g)</code>. May not be very useful in general (especially if calculating single-item values isn&#39;t efficient to begin with), but if such a matrix is available as part of the profile implementation (as with <code>Additive</code>), it may be returned directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L363-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.na" href="#Allocations.na"><code>Allocations.na</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">na(X)</code></pre><p>The number of agents represented by (e.g., profile or allocation) <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.ni" href="#Allocations.ni"><code>Allocations.ni</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ni(X)</code></pre><p>The number of items represented by (e.g., profile or allocation) <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.normalize-Tuple{Additive}" href="#Allocations.normalize-Tuple{Additive}"><code>Allocations.normalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalize(V::Additive)</code></pre><p>Scale the values of <code>V</code> such that <span>$v_i(M) = n$</span> for all agents <span>$i$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L474-L478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.owned-Tuple{Any, Any}" href="#Allocations.owned-Tuple{Any, Any}"><code>Allocations.owned</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">owned(A, g)</code></pre><p>Whether or not the item <code>g</code> is owned by any agent in the allocation <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L192-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.owner-Tuple{Any, Any}" href="#Allocations.owner-Tuple{Any, Any}"><code>Allocations.owner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">owner(A, g)</code></pre><p>The agent to which item <code>g</code> has been allocated in the allocation <code>A</code>. Will produce an error if <code>g</code> has been allocated to more than one agent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L183-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.owners-Tuple{Any, Any}" href="#Allocations.owners-Tuple{Any, Any}"><code>Allocations.owners</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">owners(A, g)</code></pre><p>The set of agents to which item <code>g</code> has been allocated in the allocation <code>A</code>. The returned <code>Set</code> should be treated as read-only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L174-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.profile-Tuple{Reduction}" href="#Allocations.profile-Tuple{Reduction}"><code>Allocations.profile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">profile(R::Reduction)</code></pre><p>Returns the valuation profile for the reduced instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L720-L724">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.required-Tuple{OrderedCategory, Any}" href="#Allocations.required-Tuple{OrderedCategory, Any}"><code>Allocations.required</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">required(c::OrderedCategory, n)</code></pre><p>The number of items the next agent must take in order to keep the instance valid, i.e., for there to be a maximum of <code>(n - 1) * threshold</code> remaining items.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L592-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.threshold-Tuple{Allocations.Category}" href="#Allocations.threshold-Tuple{Allocations.Category}"><code>Allocations.threshold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">threshold(c::Category)</code></pre><p>The maximum number of items any agent can receive from the given category, as part of a <code>Counts</code> constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L538-L543">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.transform-Tuple{Reduction, Allocation}" href="#Allocations.transform-Tuple{Reduction, Allocation}"><code>Allocations.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform(R::Reduction, A::Allocation)</code></pre><p>Converts the given allocation for the reduced instance to one for original instance. The way the convertion occurs depends on the given reduction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L736-L741">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.value" href="#Allocations.value"><code>Allocations.value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">value(V::Profile, i, S)
value(V::Profile, i, g::Int)</code></pre><p>The value agent <code>i</code> places on bundle <code>S</code>, according to the profile <code>V</code>. The second form is a shortcut for <code>value(V, i, [g])</code>; the shortcut will generally be more efficient. Note that the value of <code>S</code> may <em>not</em> in general be the sum of the values of its items; that property is unique to <code>Additive</code> profiles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L304-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.value!-Tuple{Additive, Any, Any, Any}" href="#Allocations.value!-Tuple{Additive, Any, Any, Any}"><code>Allocations.value!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value!(V::Additive, i, g::Int, v)</code></pre><p>Set the value of item <code>g</code>, according to agent <code>i</code>, to <code>v</code> in profile <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L458-L462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.value-Tuple{Additive, Any, Int64}" href="#Allocations.value-Tuple{Additive, Any, Int64}"><code>Allocations.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value(V::Additive, i, g::Int)</code></pre><p>The value of item <code>g</code>, according to agent <code>i</code> under valuation profile <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L429-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.value-Tuple{Profile, Any, Allocation}" href="#Allocations.value-Tuple{Profile, Any, Allocation}"><code>Allocations.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value(V::Profile, i, A::Allocation)</code></pre><p>The value agent <code>i</code> receives in allocation <code>A</code>, under the profile <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L316-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.value_1" href="#Allocations.value_1"><code>Allocations.value_1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">value_1(V::Profile, i, S)</code></pre><p>The value agent <code>i</code> places on bundle <code>S</code>, <em>up to one item</em>, that is, the smallest value <code>i</code> can place on bundle <code>S</code> after removing (at most) one item, according to the profile <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L327-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.value_x" href="#Allocations.value_x"><code>Allocations.value_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">value_x(V::Profile, i, S)</code></pre><p>The value agent <code>i</code> places on bundle <code>S</code>, <em>up to any item</em>, that is, the largest value <code>i</code> can place on bundle <code>S</code> after removing one item (or no items, if the bundle is empty), according to the profile <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/types.jl#L337-L343">source</a></section></article><h2 id="Checks-and-measures"><a class="docs-heading-anchor" href="#Checks-and-measures">Checks and measures</a><a id="Checks-and-measures-1"></a><a class="docs-heading-anchor-permalink" href="#Checks-and-measures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Allocations.check" href="#Allocations.check"><code>Allocations.check</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check(V, A, C)</code></pre><p>Check that the allocation <code>A</code> obeys the <code>Constraint</code> <code>C</code>, given the profile <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/checks.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.check-Tuple{Any, Any, Conflicts}" href="#Allocations.check-Tuple{Any, Any, Conflicts}"><code>Allocations.check</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check(V, A, C::Conflicts)</code></pre><p>Check whether the allocation <code>A</code> respects the item conflicts <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/checks.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.check-Tuple{Any, Any, Counts}" href="#Allocations.check-Tuple{Any, Any, Counts}"><code>Allocations.check</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check(V, A, C::Counts)</code></pre><p>Check whether the allocation <code>A</code> respects the cardinality constraints <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/checks.jl#L91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.check_complete-Tuple{Any}" href="#Allocations.check_complete-Tuple{Any}"><code>Allocations.check_complete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_complete(A)</code></pre><p>Check that the allocation is complete, or effective, in the sense that each item has been allocated to at least one agent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/checks.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.check_ef-Tuple{Any, Any}" href="#Allocations.check_ef-Tuple{Any, Any}"><code>Allocations.check_ef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_ef(V, A)</code></pre><p>Check whether the allocation <code>A</code> is <em>envy-free</em> for the profile <code>V</code>, i.e., if no agent strictly prefers another agent&#39;s bundle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/checks.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.check_ef1-Tuple{Any, Any}" href="#Allocations.check_ef1-Tuple{Any, Any}"><code>Allocations.check_ef1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_ef1(V, A)</code></pre><p>Check whether the allocation <code>A</code> is <em>envy-free up to one item</em> for the profile <code>V</code>, i.e., if no agent strictly prefers another agent&#39;s bundle, given that an appropriate (e.g., the most valuable) item is removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/checks.jl#L63-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.check_efx-Tuple{Any, Any}" href="#Allocations.check_efx-Tuple{Any, Any}"><code>Allocations.check_efx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_efx(V, A)</code></pre><p>Check whether the allocation <code>A</code> is <em>envy-free up to any item</em> for the profile <code>V</code>, i.e., if no agent strictly prefers another agent&#39;s bundle, given that an appropriate (e.g., the least valuable) item is removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/checks.jl#L73-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.check_partition-Tuple{Any}" href="#Allocations.check_partition-Tuple{Any}"><code>Allocations.check_partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_partition(A)</code></pre><p>Check that the allocation is a partition, i.e., that each item has been allocated to exactly one agent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/checks.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.nash_welfare-Tuple{Any, Any}" href="#Allocations.nash_welfare-Tuple{Any, Any}"><code>Allocations.nash_welfare</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nash_welfare(V, A; nonzero=true)</code></pre><p>Compute the Nash welfare of the allocation <code>A</code>, given the profile <code>V</code>, i.e., the product of the individual agent utilities resulting from <code>A</code>. The <code>nonzero</code> keyword indicates that agents with a utility of zero are left out. If no agents with nonzero utility exist, the result is zero. To avoid overflow with large utilities, the product is performed using floating-point arithmetic, even if the utilities are integral.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/measures.jl#L14-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.prop_alpha-Tuple{Any, Any}" href="#Allocations.prop_alpha-Tuple{Any, Any}"><code>Allocations.prop_alpha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prop_alpha(V, A)</code></pre><p>Compute the fraction of proportionality guaranteed to every agent, that is, what fraction each agent is guaranteed to get of <code>1/n</code> of their value for the grand bundle <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/measures.jl#L36-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.utility-Tuple{Any, Any}" href="#Allocations.utility-Tuple{Any, Any}"><code>Allocations.utility</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">utility(V, A)</code></pre><p>Compute the utilitarian welfare of the allocation <code>A</code>, given the profile <code>V</code>, i.e., the sum of the individual agent utilities (i.e., the bundle values) resulting from <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/measures.jl#L4-L10">source</a></section></article><h2 id="Allocation-algorithms"><a class="docs-heading-anchor" href="#Allocation-algorithms">Allocation algorithms</a><a id="Allocation-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Allocation-algorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_bb18_3-Tuple{Additive, Counts}" href="#Allocations.alloc_bb18_3-Tuple{Additive, Counts}"><code>Allocations.alloc_bb18_3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_bb18_3(V::Additive, C::Counts; a=3, ghss18_4b_warn=true)</code></pre><p>The 1/3-approximate MMS-allocation under cardinality constraints algorithm (Section 5) described by Biswas and Barman in their 2018 paper <a href="https://doi.org/10.24963/ijcai.2018/13">Fair Division Under Cardinality Constraints</a>. Finds a 1/3-approximate MMS allocation for an instance of the fair allocation problem under cardinality constraints by converting the additive instance under cardinality constraints to a submodular instance without cardinality constraints. The allocation is then found by using the method of Ghodsi et al. (<code>alloc_ghss18_4b</code>), with possible reallocation of items to satisfy the constraints. Both keyword arguments, <code>a</code> and <code>ghss18_4b_warn</code>, are passed directly to <code>alloc_ghss18_4b</code> as respectively the keyword arguments <code>a</code> and <code>x_warn</code>. See <a href="#Allocations.alloc_ghss18_4b-Tuple{Submodular}"><code>alloc_ghss18_4b</code></a> for documentation on how to use them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/algorithms.jl#L631-L645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_bkv18_1-Tuple{Any}" href="#Allocations.alloc_bkv18_1-Tuple{Any}"><code>Allocations.alloc_bkv18_1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_bkv18_1(V; randpri=true)</code></pre><p>The first algorithm (<strong>Alg-Identical</strong>) described by Barman, Krishnamurty and Vaish in their 2018 paper <a href="https://doi.org/10.1145/3355902">Greedy Algorithms for Maximizing Nash Social Welfare</a>. The algorithm finds a 1.061-approximate MNW allocation when agents have identical valuations, i.e., for any agents <code>i</code>, <code>j</code> and item <code>g</code>, <code>value(V, i, g) == value(V, j, g)</code>. (This approximation ratio applies to the geometric mean of agent utilities, not the raw product.) The result will also be envy-free up to any item (EFX).</p><p>The algorithm follows a straightforward greedy allocation procedure, where in each iteration, the most valuable item is allocated to the agent with the lowest utility. By default, ties are broken by giving the agents random priorities; if <code>randpri</code> is set to false, they are instead broken lexicographically (as specified by Barman et al.), so that the agent with the lower index is preferred.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/algorithms.jl#L222-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_bkv18_2-Tuple{Any}" href="#Allocations.alloc_bkv18_2-Tuple{Any}"><code>Allocations.alloc_bkv18_2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_bkv18_2(V; randpri=true, complete=false)
alloc_hpps20_1(V; randpri=true, complete=false) # alias</code></pre><p>The second algorithm (<strong>Alg-Binary</strong>) described by Barman, Krishnamurty and Vaish in their 2018 paper <a href="https://doi.org/10.1145/3355902">Greedy Algorithms for Maximizing Nash Social Welfare</a>. The algorithm finds MNW allocations in polynomial time for binary additive valuations, i.e., where each agent values any given object at 0 or 1 (e.g., an <code>Additive{BitMatrix}</code>). It also works in a more general setting, where <code>value(V, i, S)</code>, for any given <code>i</code>, is a concave function of the number of items <code>g</code> in <code>S</code> for which <code>value(V, i, g) == 1</code>.</p><p>The original algorithm builds on an initial allocation, but does not specify what this allocation should be. It also does not deal with the case where one or more agents ends up with zero utility; in fact the procedure will not work even if we start with two or more agents with zero utility in the intial allocation. The strategy followed here is the same as that of <a href="https://doi.org/10.1145/3355902">Caragiannis et al.</a>, where a maximum cardinality set of agents achieving positive utility is found using bipartite matching (with no fairness considerations). The remaining items are randomly allocated to agents among these that value them, if any. Remaining agents and items are ignored by the procedure.</p><p>Following the algorithm of Barman et al., the tie-breaking procedure (Algorithm 1) of <a href="http://arxiv.org/abs/2007.06073">Halpern et al.</a> is used, where the MNW allocation is transformed into the lexicographically greatest MNW, according to some ordering of the agents, providing group-strategyproofness (GSP) in addition to the EF1 and PO guarantees that follow from MNW. By default, the agent ordering/priority is random; if this randomization is turned off (with <code>randpri</code> set to false), the default ordering is used, with agent <code>1</code> receiving the highest priority, etc.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Despite the use of randomization here, by default, this is the <em>deterministic</em> procedure of Halpern et al. They also describe a randomized procedure, which functions in an entirely different manner.</p></div></div><p>Finally, if the <code>complete</code> argument is set to <code>true</code>, the allocation is completed with <code>fill_even!</code> (which means that some agents that must necessarily get a utility of zero can still receive items valued zero, if that evens out the bundle cardinalities). Note that this undermines the GSP guarantee, which requires that these items be discarded. The return value is a named tuple with the fields <code>alloc</code> (the <code>Allocation</code>) and <code>mnw</code> (the Nash welfare, ignoring agents with zero utility).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/algorithms.jl#L272-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_ghss18_4-Tuple{Submodular, Any}" href="#Allocations.alloc_ghss18_4-Tuple{Submodular, Any}"><code>Allocations.alloc_ghss18_4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_ghss18_4(V::Submodular, MMSs)</code></pre><p>The fourth algorithm (<strong>Algorithm 4</strong>) described by Ghodsi et al. in the 2018 paper <a href="https://arxiv.org/abs/1704.00222">Fair allocation of Indivisible Goods: Improvements and Generalizations</a>. The algorithm finds a 1/3-approximate MMS allocation for a given submodular instance and corresponding maximin shares for the agents (<code>MMSs[i]</code> should be the MMS of agent <code>i</code>). If the supplied maximin shares, are higher than the actual maximin shares, the method may fail. In that case, this will be indicated in the result, where <code>res.fail</code> will be set to true and <code>res.agent</code> will be set to the agent last considered when the method failed to improve. If the maximin shares are unknown, use <code>alloc_ghss18_4b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/algorithms.jl#L499-L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_ghss18_4b-Tuple{Submodular}" href="#Allocations.alloc_ghss18_4b-Tuple{Submodular}"><code>Allocations.alloc_ghss18_4b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_ghss18_4b(V::Submodular; a=3, x_warn=true)</code></pre><p>A variation on the fourth algorithm (<strong>Algorithm 4</strong>) described by Ghodsi et al. in the 2018 paper <a href="https://arxiv.org/abs/1704.00222">Fair allocation of Indivisible Goods: Improvements and Generalizations</a>. The algorithm finds a 1/3-approximate MMS allocation for a given submodular instance. The method starts by overestimating the MMS of each agent and slowly decreasing the MMS of specific agents until <code>alloc_ghss18_4</code> returns an allocation.</p><p>The amount that the MMS of an agent should be reduced by in each iteration is not specified by Ghodsi et al. One can show that if the factor is <code>1/(1 + 1/x)</code>, where <code>x ≥ 3n - 1</code>, then the algorithm will successfully find a 1/3-approximate MMS allocation. One way to show this, is to modify Lemma 4.6 in their paper to assume that each of the bundles <code>Sᵢ</code> is valued at least <code>1/(1 + 1/x)</code>. Using this modified version of Lemma 4.6, one can modify the proof of Theorem 4.7 to show that as long as <code>x ≥ 3n - 1</code>, the change in expectance from moving an item is at least <code>1/(3m)</code>. The value of <code>x</code> used in this implementation is <code>x = an</code>, where the keyword argument <code>a</code> is set to <code>3</code> by default (i.e., <code>x = 3n</code>). If <code>a</code> is set so that <code>x &lt; 3n - 1</code> a warning will be given. The warning can be turned off by setting <code>x_warn</code> to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/algorithms.jl#L590-L611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_gmt18-Tuple{Additive}" href="#Allocations.alloc_gmt18-Tuple{Additive}"><code>Allocations.alloc_gmt18</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_gmt18(V)</code></pre><p>The 2/3-approximate MMS allocation algorithm described by Garg, McGlaughlin and Taki in their 2018 paper <a href="https://doi.org/10.4230/OASICS.SOSA.2019.20">Approximating Maximin Share Allocations</a>. The algorithm finds a 2/3-approximate MMS allocation for an instance with additive valuations. The algorithm works by performing a set of reductions to simplify the instance, limiting the maximum value of a good and the number of high-valued goods. The algorithm then uses bag-filling to allocate the remaining goods to the remaining agents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/algorithms.jl#L707-L718">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_half_mms" href="#Allocations.alloc_half_mms"><code>Allocations.alloc_half_mms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alloc_half_mms(V::Additive, C::Counts)</code></pre><p>Find a 1/2-approximate MMS allocation that obeys the constraints imposed by <code>C</code>. The allocation is found using <code>alloc_hh22_1</code>. See <a href="#Allocations.alloc_hh22_1-Tuple{Additive, Counts}"><code>alloc_hh22_1</code></a> for a detailed description of how the method works.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/algorithms.jl#L771-L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_hh22_1-Tuple{Additive, Counts}" href="#Allocations.alloc_hh22_1-Tuple{Additive, Counts}"><code>Allocations.alloc_hh22_1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_hh22_1(V::Additive, C::Counts; α=0.5)</code></pre><p>The 1/2-approximate MMS allocation under cardinality constraints algorithm (Algorithm 3) described by Hummel and Hetland in their <a href="https://doi.org/10.1007/978-3-031-20614-6_11">Maximin Shares Under Cardinality Constraints</a> (2022). First the instance is reduced to an ordered normalized instance where each good is worth less than 1/2. While there are more than one agent remaining, the algorithm creates a bundle with the <span>$⌊|\text{category}|/n⌋$</span> lowest-valued items in each category. Repeatedly, it converts each of these to the highest-valued remaining item in the category until it either runs out of items to convert or an agent values the bundle at least 1/2. If the procedure runs out of items to convert, it adds the highest-valued remaining item in each category, in order, to get <span>$⌈|\text{category}|/n⌉$</span> items from each category.  After each such item is added, the value is again checked for each agent. Since the instance was ordered normalized and without items worth 1/2 or more, the bundle created will always be worth more than 1/2 to one of the remaining agents before the procedure runs out of items to add to it or convert from low- to high-valued.</p><p>Another approximation ratio, <code>α</code>, can be supplied. If <code>α ≤ 0.5</code> the algorithm is guaranteed to succeed. Otherwise, the method will try to find an allocation with an approximation ratio of <code>α</code>, but may fail. In the latter case, the results will indicate a failure by setting <code>res.fail</code> to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/algorithms.jl#L4-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_rand-Tuple{Any, Conflicts}" href="#Allocations.alloc_rand-Tuple{Any, Conflicts}"><code>Allocations.alloc_rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_rand(V, C::Conflicts)</code></pre><p>Allocate items to agents randomly, respecting the item conflicts. Uses the <a href="https://doi.org/10.1007/978-3-540-70575-8_26">randomized coloring procedure with symmetry-breaking</a> of Pemmaraju and Srinivasan, which works as follows:</p><ol><li>Give the items random priorities, corresponding to a permutation selected uniformly at ramdom.</li><li>Tentatively allocate each item randomly to an agent, without concern for the item conflicts.</li><li>If an agent has received conflicting items, it keeps the highest-priority item (i.e., earliest in the permutation), and the others are reallocated arbitrarily.</li></ol><p>This final arbitrary reallocation is also performed randomly in this implementation, by going through the items in random order, allocating each to a randomly selected agent among those able to receive it.</p><p>The valuation profile <code>V</code> is not used, other than to determine the number of agents and items.</p><p>For this algorithm to function properly, the maximum degree of the conflict graph should be strictly less than the number of agents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/algorithms.jl#L134-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_rand-Tuple{Any}" href="#Allocations.alloc_rand-Tuple{Any}"><code>Allocations.alloc_rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_rand(V)</code></pre><p>A straightforward lottery that allocates the items randomly to the agents. For each item, its agent is selected uniformly at random. The valuation profile <code>V</code> is not used, other than to determine the number of agents and items. The return value is a named tuple with the field <code>alloc</code> (the <code>Allocation</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/algorithms.jl#L103-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_rand-Tuple{Int64, Int64, Conflicts}" href="#Allocations.alloc_rand-Tuple{Int64, Int64, Conflicts}"><code>Allocations.alloc_rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_rand(n::Int, m::Int, C::Conflicts)</code></pre><p>Same as <code>alloc_rand(V, C)</code>, for <code>n</code> agents and <code>m</code> items.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/algorithms.jl#L163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_rand-Tuple{Int64, Int64}" href="#Allocations.alloc_rand-Tuple{Int64, Int64}"><code>Allocations.alloc_rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_rand(n::Int, m::Int)</code></pre><p>Same as <code>alloc_rand(V)</code>, for <code>n</code> agents and <code>m</code> items.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/algorithms.jl#L114-L118">source</a></section></article><h3 id="Reductions"><a class="docs-heading-anchor" href="#Reductions">Reductions</a><a id="Reductions-1"></a><a class="docs-heading-anchor-permalink" href="#Reductions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Allocations.order-Tuple{Additive, Counts}" href="#Allocations.order-Tuple{Additive, Counts}"><code>Allocations.order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">order(V::Additive, C::Counts)</code></pre><p>Create an ordered instance for the given weights and categories. The items are reorded such that each category has a continous range of indices for its items. Returns a reduction, with a transformation that converts an allocation to one in the original instance where each agent gets at least the same value as in the ordered instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/reductions.jl#L313-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.order-Tuple{Additive}" href="#Allocations.order-Tuple{Additive}"><code>Allocations.order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">order(V::Additive)</code></pre><p>Create an ordered instance for the given weights. The weights are reordered for each agent such that item 1 is worth the most and item m is worth the least. Returns new additive valuations and a function to convert an allocation in the ordered instance into one for the original instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/reductions.jl#L278-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.reduce-Tuple{Additive, Counts{OrderedCategory}, Any, Any}" href="#Allocations.reduce-Tuple{Additive, Counts{OrderedCategory}, Any, Any}"><code>Allocations.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(V::Additive, C::Counts{OrderedCategory}, i, B)</code></pre><p>Reduce the instance given by the pair (V, C) to a new instance by giving the supplied agent, <code>i</code>, the supplied bundle, <code>B</code>. Returns a reduction, where the transformation, in addition to converting the allocation to one for the original instance, allocates <code>B</code> to <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/reductions.jl#L73-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.reduce-Tuple{Additive, Counts{OrderedCategory}, Real}" href="#Allocations.reduce-Tuple{Additive, Counts{OrderedCategory}, Real}"><code>Allocations.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(V::Additive, C::Counts{OrderedCategory}, α)</code></pre><p>Reduce an ordered instance by normalizing the values and giving any agent that value an individual item greater than or equal to α the item and any low value items required to reduce to a valid instance. This reduction is performed recursively until no more such items exist. The reduction does not decrease the MMS guarantee of any remaining agents and all agents that are allocated a bundle in the reduction is guaranteed to value their bundle at least α of their MMS guarantee.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/reductions.jl#L208-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.reduce-Tuple{Additive, Real}" href="#Allocations.reduce-Tuple{Additive, Real}"><code>Allocations.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(V::Additive, α::Real; greedy::Bool=true)</code></pre><p>Reduce an ordered instance by normalizing the values and giving any agent that value an individual item greater than or equal to α the item.  This reduction is performed recursively until no more such items exist. The reduction does not decrease the MMS guarantee of any remaining agents and all agents that are allocated a bundle in the reduction is guaranteed to value their bundle at least α of their MMS guarantee. The agent-item pairs are either selected greedily or by finding a maximum matching between agents and such items.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/reductions.jl#L163-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.reduce-Tuple{Additive, Vararg{Function}}" href="#Allocations.reduce-Tuple{Additive, Vararg{Function}}"><code>Allocations.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(V::Additive, F::Function...)</code></pre><p>Reduce an instance V by repeatedly applying the functions f ∈ F to find bundles to be allocated. The functions in F are expected to return either a pair, <code>(i, B)</code>, consisting of an agent <code>i</code> and the bundle <code>B</code> to be assigned to agent <code>i</code>, or the value <code>nothing</code> if the function couldn&#39;t find a valid bundle-agent-pair. The functions are called in prioritized order and the instance is reduced and normalized between each invocation. The functions are invoked with the valuation matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/reductions.jl#L130-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.reduce-Tuple{Profile, Real}" href="#Allocations.reduce-Tuple{Profile, Real}"><code>Allocations.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(V::Profile, α::Real)</code></pre><p>Produce a reduced instance by giving an item to any agent that values it at <code>α</code> or more. This reduction is performed repeatedly, until no such item exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/reductions.jl#L252-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.reduce-Tuple{Profile, Vararg{Pair}}" href="#Allocations.reduce-Tuple{Profile, Vararg{Pair}}"><code>Allocations.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(V::Valuation, assignment::Pair...)</code></pre><p>Reduce the instance given to a new instance where the involved agents and bundles in the assignments are removed. Returns new valuations and a function that turns an allocation in the reduced instance into one for the original instance, including giving the supplied agent the supplied bundle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/reductions.jl#L62-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.reduce-Tuple{Submodular, Any, Any}" href="#Allocations.reduce-Tuple{Submodular, Any, Any}"><code>Allocations.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(V::Submodular, i, B)</code></pre><p>Reduce the instance given by <code>V</code> to a new instance by giving the specified bundle, <code>B</code>, to agent <code>i</code>. Returns a reduction, where the transformation, in addition to converting the allocation to one for the original instance, allocates <code>B</code> to <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/reductions.jl#L97-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.reduceutil-Tuple{Profile, Vararg{Pair}}" href="#Allocations.reduceutil-Tuple{Profile, Vararg{Pair}}"><code>Allocations.reduceutil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduceutil(V::Profile, assignments::Pair...)</code></pre><p>Utility function that given valuations and a collection of assignments of bundles to agents (<code>i =&gt; B</code>), creates a reduced instance, translation tables from the reduced instance and a function to convert an allocation in the reduced instance to one in the original instance – including the given assignements. The function returns a <code>Reduction</code> object without any constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/reductions.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.reducevaluation-Tuple{Additive, Any, Any}" href="#Allocations.reducevaluation-Tuple{Additive, Any, Any}"><code>Allocations.reducevaluation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reducevaluation(V::Additive, λi, λg)</code></pre><p>Utility function that given additive valuations prior to a reduction and translation tables for the reduction, returns new additive valuations for the reduced instance. The new valuations are as prior to the reduction, except for missing items/agents and changes in item/agent numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/reductions.jl#L34-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.reducevaluation-Tuple{Submodular, Any, Any}" href="#Allocations.reducevaluation-Tuple{Submodular, Any, Any}"><code>Allocations.reducevaluation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reducevaluation(V::Submodular, λi, λg)</code></pre><p>Utility function that given submodular valuations prior to a reduction and translation tables for the reduction, returns new submodular valuations for the reduced instance. The new valuations are as prior to the reduction, except for missing items/agents and changes in item/agent numbers. That is, the new valuation functions work by translating the item numbers to what they would be prior to the reduction and calling the valuation function of the agent prior to the reduction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/reductions.jl#L45-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.revert-NTuple{4, Any}" href="#Allocations.revert-NTuple{4, Any}"><code>Allocations.revert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">revert(λi, λg, assignments, A)</code></pre><p>Convert an allocation for a reduced instance to one for the original instance, including giving the removed bundles to the removed agents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/reductions.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.revert-Tuple{Additive, Any}" href="#Allocations.revert-Tuple{Additive, Any}"><code>Allocations.revert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">revert(V::Additive, A)</code></pre><p>Convert an allocation for the ordered instance to one for the original instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/reductions.jl#L291-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.revert-Tuple{Additive, Counts, Counts, Any}" href="#Allocations.revert-Tuple{Additive, Counts, Counts, Any}"><code>Allocations.revert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">revert(V::Additive, C::Counts, C′::Counts, A)</code></pre><p>Convert an allocation for the ordered instance (<code>C′</code>) to one for the original instance <code>(V, C)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/reductions.jl#L343-L348">source</a></section></article><h2 id="MIP-based-allocation"><a class="docs-heading-anchor" href="#MIP-based-allocation">MIP-based allocation</a><a id="MIP-based-allocation-1"></a><a class="docs-heading-anchor-permalink" href="#MIP-based-allocation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_ef1-Tuple{Any, Any}" href="#Allocations.alloc_ef1-Tuple{Any, Any}"><code>Allocations.alloc_ef1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_ef1(V, C; solver=conf.MIP_SOLVER, kwds...)</code></pre><p>Create an <code>Allocation</code> that is envy-free up to one item (EF1), based on the valuation profile <code>V</code>, possibly subject to the constraints given by the <code>Constraint</code> object <code>C</code>. The solution is found using a straightforward mixed-integer program, and is most suitable for constraints where no specialized algorithm exists. For example, without constraints, a straightforward round robin picking sequence yields EF1, and a similar strategy works for cardinality constraints. (It is still possible to use this function without constraints, by explicitly supplying <code>nothing</code> for the constraint argument <code>C</code>.) The return value is a named tuple with the fields <code>alloc</code> (the <code>Allocation</code>) and <code>model</code> (the JuMP model used in the computation).</p><p>Lower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments <code>min_bundle</code>, <code>max_bundle</code>, <code>min_owners</code> and <code>max_owners</code>, the latter two of which default to <code>1</code>. If one of these is <code>nothing</code>, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.</p><p>Note that for some constraints, there may not <em>be</em> an EF1 allocation, in which case the function will fail with an exception.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/mip.jl#L353-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_efx" href="#Allocations.alloc_efx"><code>Allocations.alloc_efx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alloc_efx(V[, C]; solver=conf.MIP_SOLVER, kwds...)</code></pre><p>Create an <code>Allocation</code> that is envy-free up to any item (EFX), based on the valuation profile <code>V</code>, possibly subject to the constraints given by the <code>Constraint</code> object <code>C</code>. The solution is found using a straightforward mixed-integer program. The return value is a named tuple with the fields <code>alloc</code> (the <code>Allocation</code>) and <code>model</code> (the JuMP model used in the computation).</p><p>Lower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments <code>min_bundle</code>, <code>max_bundle</code>, <code>min_owners</code> and <code>max_owners</code>, the latter two of which default to <code>1</code>. If one of these is <code>nothing</code>, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.</p><p>Note that while some constraints may prevent an exact EFX allocation, it is currently (Mar 2021) an open question whether EFX always exists in the unconstrained case (see, e.g., <a href="https://arxiv.org/abs/2103.01628">Improving EFX Guarantees through Rainbow Cycle Number</a> by Chaudhury et al.).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/mip.jl#L383-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_ggi" href="#Allocations.alloc_ggi"><code>Allocations.alloc_ggi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alloc_ggi(V[, C]; wt=wt_gini, solver=conf.MIP_SOLVER, kwds...)</code></pre><p>Maximizes a generalized Gini index (GGI), also known as a generalized Gini social-evaluation functions. The function being maximized is an ordered weighted average (OWA) of agent utilities, utilities, where the weight is based on utility rank <code>i</code>, from the least happy (<code>1</code>) to the most happy (<code>n</code>), parameterized by the function <code>wt(i, n)</code>. It is generally assumed that the weights are nondecreasing in <code>i</code>. Note that there is no need to use normalized weights (i.e., to produce a weighted average, despite the term OWA), as is often the case when such measures are used to measure <em>in</em>equality (e.g., by subtracting the OWA from an ordinary average, cf. <a href="https://doi.org/10.1016/0165-4896(81)90018-4">Generalized gini inequality indices</a> by John A. Weymark).</p><p>The default <code>wt_gini</code> gives the (non-normalized) weights of the original Gini social-evaluation. Two other notable cases for <code>wt</code> are <code>(i, _) -&gt; i == 1</code>, which yields a maximin allocation, and <code>(i, _) -&gt; 1</code>, which yields a purely utilitarian allocation (with no consideration for fairness). The solution method used is based on that of Lesca and Perny (linear formulation <span>$\Pi&#39;_W$</span>) in their paper 2010 paper <a href="https://doi.org/10.3233/978-1-60750-606-5-393">“LP Solvable Models for Multiagent Fair Allocation Problems”</a>. The return value is a named tuple with the fields <code>alloc</code> (the <code>Allocation</code> that has been produced) and <code>model</code> (the JuMP model used in the computation).</p><p>Lower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments <code>min_bundle</code>, <code>max_bundle</code>, <code>min_owners</code> and <code>max_owners</code>, the latter two of which default to <code>1</code>. If one of these is <code>nothing</code>, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.</p><p>In the original inequality measures, the mean agent utility is included as a normalizing term, which is harmless for the case of identical valuations functions (and when looking at, say, the distribution of incomes), but when valuations differ, this mean will vary with the allocations. As pointed out by Lesca and Perny, such a measure is not monotone with Pareto dominance – the optimization will tend to drive the mean utility <em>down</em>. Therefore only the term measuring (in)equality (i.e., the ordered weighted sum of agent utilities) is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/mip.jl#L656-L690">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_mm" href="#Allocations.alloc_mm"><code>Allocations.alloc_mm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alloc_mm(V[, C]; cutoff=nothing, solver=conf.MIP_SOLVER, kwds...)</code></pre><p>Create an egalitarion or maximin <code>Allocation</code>, i.e., one where the minimum bundle value is maximized. The <code>cutoff</code>, if any, is a level at which we are satisfied, i.e., any allocation where all agents attain this value is acceptable. The return value is a named tuple with fields <code>alloc</code> (the <code>Allocation</code>), <code>mm</code> (the lowest agent utility) and <code>model</code> (the JuMP model used in the computation).</p><p>Lower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments <code>min_bundle</code>, <code>max_bundle</code>, <code>min_owners</code> and <code>max_owners</code>, the latter two of which default to <code>1</code>. If one of these is <code>nothing</code>, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/mip.jl#L508-L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_mms" href="#Allocations.alloc_mms"><code>Allocations.alloc_mms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alloc_mms(V[, C]; cutoff=false, solver=conf.MIP_SOLVER, kwds...)</code></pre><p>Find an MMS allocation, i.e., one that satisfies the <em>maximin share guarantee</em>, where each agent gets a bundle it weakly prefers to its maximin share (introduced by Budish, in his 2011 paper <a href="https://doi.org/10.1086/664613">The Combinatorial Assignment Problem: Approximate Competitive Equilibrium from Equal Incomes</a>). The return value is a named tuple with fields <code>alloc</code> (the <code>Allocation</code>), <code>mmss</code>, the individual MMS values for the instance, <code>alpha</code>, the lowest fraction of MMS that any agent achieves (is at least 1 exactly when the allocation is MMS), <code>model</code> (the JuMP model used in computing <code>alpha</code>) and <code>mms_models</code> (the JuMP models used to compute the individual maximin shares). If <code>cutoff</code> is set to <code>true</code>, this fraction is capped at 1.</p><p>Lower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments <code>min_bundle</code>, <code>max_bundle</code>, <code>min_owners</code> and <code>max_owners</code>, the latter two of which default to <code>1</code>. If one of these is <code>nothing</code>, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.</p><p>Because of how they interact with the calculation of MMS, the agent-asymmetric limits <code>min_bundle</code> and <code>max_bundle</code> must be scalars (or, more generally, satisfy <code>allequal</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/mip.jl#L584-L601">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_mnw" href="#Allocations.alloc_mnw"><code>Allocations.alloc_mnw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alloc_mnw(V[, C]; mnw_warn=false, solver=conf.MIP_SOLVER, kwds...)</code></pre><p>Create an <code>Allocation</code> attaining maximum Nash welfare (MNW), based on the valuation profile <code>V</code>, possibly subject to the constraints given by the <code>Constraint</code> object <code>C</code>. The solution is found using the approach of Caragiannis et al. in their 2019 paper <a href="https://doi.org/10.1145/3355902">The Unreasonable Fairness of Maximum Nash Welfare</a>, with two minor modifications:</p><ol><li><p>Rather than hard-coding a maximum valuation (arising from the assumption that the values of each agent sum to 1000), this maximum is extracted from <code>V</code>; and</p></li><li><p>Extra constraints are permitted (through the object <code>C</code>), possibly lowering the attainable MNW.</p></li></ol><p>Because of how the integer program is constructed, it may be affected by precision effects, where a high number of agents can make it impossible to guarantee Pareto optimalty (PO), EF1 or MNW. If the precision is too low, the appropriate warning will be issued, but the computation is not halted. Note that these warnings are quite conservative (see note below). This is particularly true of the one for MNW, which is disabled by default, in part because of its sensitivity, and in part because it will generally be useful to find solutions that satisfy PO and EF1, even if it may not be exactly MNW. The MNW warning can be enabled by setting the <code>mnw_warn</code> keyword to <code>true</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The warnings are based on the lower bounds described by Caragiannis et al. On the one hand, the bound is only used to test whether current floating-point precision is sufficient; any tolerance or gap used by the solver is not used, which might in principle mean that false negatives are possible. On the other hand, these bounds, especially the one for exact MNW, may in practice be quite loose, with small variations in agent utilities leading to large changes in objective value, unless the changes are finely tuned to cancel out.</p></div></div><p>The return value is a named tuple with fields <code>alloc</code> (the <code>Allocation</code>), <code>mnw</code> (the achieved Nash welfare for the agents with nonzero utility), <code>mnw_prec</code> (whether or not there was enough precision to satisfy the lower bound guaranteeing exact MNW) and <code>model</code> (the JuMP model used in the computation).</p><p>Lower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments <code>min_bundle</code>, <code>max_bundle</code>, <code>min_owners</code> and <code>max_owners</code>, the latter two of which default to <code>1</code>. If one of these is <code>nothing</code>, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/mip.jl#L422-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.alloc_mnw_ef1-Tuple{Any, Any}" href="#Allocations.alloc_mnw_ef1-Tuple{Any, Any}"><code>Allocations.alloc_mnw_ef1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloc_mnw_ef1(V, C; mnw_warn=true, solver=conf.MIP_SOLVER, kwds...)</code></pre><p>Equivalent to <code>alloc_mnw</code>, except that EF1 is enforced. Without any added constraints, MNW implies EF1, so this function is not needed in that case. Therefore the argument <code>C</code> is not optional.</p><p>Lower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments <code>min_bundle</code>, <code>max_bundle</code>, <code>min_owners</code> and <code>max_owners</code>, the latter two of which default to <code>1</code>. If one of these is <code>nothing</code>, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/mip.jl#L478-L486">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.mms" href="#Allocations.mms"><code>Allocations.mms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mms(V, i[, C]; solver=conf.MIP_SOLVER, kwds...)</code></pre><p>Determine the maximin share of agent <code>i</code>, i.e., the bundle value she is guaranteed to attain if she partitions the items and the other agents choose their bundles. Useful, e.g., as a point of reference when determining the empirical approximation ratios of approximate MMS allocation algorithms. Also used as a subroutine in <code>alloc_mms</code>. The return value is a named tuple with the fields <code>mms</code> (the maximin share of agent <code>i</code>) and <code>model</code> (the JuMP model used in the computation).</p><p>Lower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments <code>min_bundle</code>, <code>max_bundle</code>, <code>min_owners</code> and <code>max_owners</code>, the latter two of which default to <code>1</code>. If one of these is <code>nothing</code>, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.</p><p>Because of how they interact with the calculation of MMS, the agent-asymmetric limits <code>min_bundle</code> and <code>max_bundle</code> must be scalars (or, more generally, satisfy <code>allequal</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/mip.jl#L531-L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.mms_alpha-Tuple{Any, Any, Any}" href="#Allocations.mms_alpha-Tuple{Any, Any, Any}"><code>Allocations.mms_alpha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mms_alpha(V, A, mmss)</code></pre><p>Utility function to find the fraction of the maximin share guarantee attained by the allocation <code>A</code>, under the valuation profile <code>V</code>, where <code>mmss[i]</code> is the MMS of agent <code>i</code>. This makes it possible, for example, to use the <code>mmss</code> field from the result of <code>alloc_mms</code> to find the MMS approximation provided by an allocation constructed by other means. For example:</p><pre><code class="nohighlight hljs">mmss = alloc_mms(V).mmss
A = alloc_rand(V).alloc
alpha = mms_alpha(V, A, mmss)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/mip.jl#L564-L577">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Allocations.wt_gini-Tuple{Any, Any}" href="#Allocations.wt_gini-Tuple{Any, Any}"><code>Allocations.wt_gini</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wt_gini(i, n)</code></pre><p>The (unnormalized) weights used in the ordered weighted average in the Gini social-evaluation function, where the utility of the <code>i</code>th agent, ordered by increasing utility, is given weight <span>$2(n - i) + 1$</span>. (The normalized weights yielding the original Gini social-evaluation function are divided by <span>$n^2$</span>, but this makes no difference to the optimization problem.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/mip.jl#L644-L652">source</a></section></article><h2 id="Configuration"><a class="docs-heading-anchor" href="#Configuration">Configuration</a><a id="Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Allocations.conf" href="#Allocations.conf"><code>Allocations.conf</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">conf</code></pre><p>A struct with fields for global configuration of the <code>Allocations</code> module.</p><p><strong>Fields</strong></p><pre><code class="language-julia hljs">MIP_SOLVER::Any</code></pre><p>The (factory for the) JuMP optimizer to be used (by default) for mixed-integer programming. Initially set to <code>HiGHS.Optimizer</code>, with <code>log_to_console</code> set to <code>false</code>. This can be overridden either by setting <code>MIP_SOLVER</code> to another value (e.g., using the JuMP function <code>optimizer_with_attributes</code>) or by passing the solver directly to the appropriate allocation functions.</p><pre><code class="language-julia hljs">MIP_SUCCESS::Any</code></pre><p>Container of acceptable MIP statuses. By default, has the value <code>[MOI.OPTIMAL]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlhetland/Allocations.jl/blob/4df121a517147054b77c0472ffde963b335c4a91/src/conf.jl#L6-L30">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Allocations.jl</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 2 March 2023 11:54">Thursday 2 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
