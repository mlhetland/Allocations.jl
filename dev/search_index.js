var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = Allocations","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"julia> using Allocations","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Function naming: Allocation functions that use a straightforward procedure, or simply use a solver to enforce some property, are named after that procedure or property (such as alloc_rand or alloc_ef1). For published algorithms, the package uses a naming scheme based on the original publication.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"The root of the function name is alloc_, followed by a publication code:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"For a single-author paper, the first three letters of the author's last name are used;\nfor multi-author papers, the first letter of the first four authors are concatenated.\nTo this, the last two digits of the year are added.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"For example, the 2/3-MMS algorithm of Garg, McGlaughlin and Taki (2018) is implemented by alloc_gmt18.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"If the same code applies to multiple publications, they are distinguished by a suffix a, b, etc., after the year digits.\nIf a single publication discusses multiple algorithms, a number such as _1, _2, etc., is added. So, for example, the third algorithm described by Biswas and Barman (2018) is alloc_bb18_3.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Some functions (such as alloc_hh22_1) are given generic names as aliases (in this case, alloc_half_mms).","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"note: Note\nThese publication codes are similar to the authorship trigraphs used in some citation styles. Specifically, they follow the conventions of alpha.bst, except that an \"et al.\" character is not added when there are five or more authors.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Accessors: Using accessors such as attr(obj) rather than obj.attr comes with the cost of claiming names in the global namespace, so they are mainly used when they provide some value, and not as a general convention. Such added value may be, for example, that it makes the interface clearer or more consistent, or that it provides some modest level of encapsulation. In many cases, it may also be worthwhile to use a function to access elements of an internal collection (such as foo(X, i) rather than X.foo[i]).","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"If, however, an object is essentially a named tuple, attributes will tend to be used without accessors. This applies to thin wrapper (such as Conflicts, for example), where the inner object is simply accessed directly.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Note that some such objects used accessors in earlier versions. These accessors are still available, but their use is deprecated. (Run julia with --depwarn=true to get the appropriate warnings.)","category":"page"},{"location":"reference/#types","page":"Reference","title":"Basic types","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Allocations]\nPages = [\"types.jl\"]","category":"page"},{"location":"reference/#Allocations.Additive","page":"Reference","title":"Allocations.Additive","text":"struct Additive{T <: AbstractMatrix} <: Profile\n\nAn additive valuation profile, representing how each agent values all possible bundles. Because of additivity, this is easily \"lifted\" from the values of individual items, by addition, with an empty bundle given a value of zero. By default, the profile is constructed from a real matrix X, supplied to the default constructor, where X[i, g] is agent i's value for item g.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Additive-Tuple{Any, Any}","page":"Reference","title":"Allocations.Additive","text":"Additive(n, m)\n\nCreate an additive profile for n agents and m items where all values are set to zero.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Allocation","page":"Reference","title":"Allocations.Allocation","text":"struct Allocation <: Any\n\nA mapping A from agents i to their assigned bundles bundle(A, i). Agents and items are represented as Ints, and bundles as Sets of Ints. The Allocation also maintains an inverse mapping, from items g to their set of owners, owners(A, g). To keep these in sync, the bundles should be modified using give! and deny!, rather than altering the bundle sets directly.\n\nAllocations support iteration (along with length and isempty), which acts as for a map from agents to bundles, i.e., it generates a series of pairs i => S, where i is an agent, and S is the corresponding bundle.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Allocation-2","page":"Reference","title":"Allocations.Allocation","text":"Allocation(n::Int, m::Int[, bundles])\nAllocation(n::Int, m::Int, bundles::Pair...)\n\nConstruct an empty allocation with n agents and m items. If the bundles argument is provided, it should be iterable, with length-2 elements, such as Pairs or 2-tuples (i, x) or agents i and bundles – or individual items – x they should receive. Agents may occur multiple times, and will then receive all the bundles or items specified. These bundle assignments need not form a partition of the item set.\n\nExamples\n\njulia> Allocation(5, 10, [1 => [1, 2, 3]])\nAllocation with 5 agents and 10 items, 7 unallocated:\n  1 => {1, 2, 3}\n  2 => {}\n  3 => {}\n  4 => {}\n  5 => {}\n\nThe bundles assignment pairs may also be provided as individual Pairs:\n\njulia> Allocation(3, 3, 1 => [2], 2 => [3, 1], 3 => 2, 3 => 3)\nAllocation with 3 agents and 3 items:\n  1 => {2}\n  2 => {1, 3}\n  3 => {2, 3}\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Allocation-Tuple{Allocation}","page":"Reference","title":"Allocations.Allocation","text":"Allocation(A::Allocation)\n\nConstruct a new allocation that has the same agents, items and bundles as A. Because an Allocation is an iterable collection of agent–bundle pairs, this is equivalent to the more general Allocation(bundles) constructor, just slightly more efficient, because the number of agents and items are retrieved directly from A.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Allocation-Tuple{Any}","page":"Reference","title":"Allocations.Allocation","text":"Allocation(bundles)\nAllocation(bundles::Pair...)\n\nEquivalent to Allocation(n, m, bundles), where n and m are determined from the bundles argument.\n\nExamples\n\njulia> Allocation([1 => [1, 2, 3]])\nAllocation with 1 agent and 3 items:\n  1 => {1, 2, 3}\n\njulia> Allocation(1 => [2], 2 => [3, 1], 3 => 2, 3 => 3)\nAllocation with 3 agents and 3 items:\n  1 => {2}\n  2 => {1, 3}\n  3 => {2, 3}\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Allocation-Tuple{Profile, Vararg{Any}}","page":"Reference","title":"Allocations.Allocation","text":"Allocation(V::Profile, args...)\n\nConstruct an allocation with a number of agents and items equal to that of the instance (i.e., profile) V. Additional arguments may be provided as for the constructor with explicit n and m arguments.\n\nExamples\n\njulia> V = Profile([1 2; 2 1])\nAdditive{Matrix{Int64}} with 2 agents and 2 items:\n 1  2\n 2  1\n\njulia> A = Allocation(V, 1 => 2)\nAllocation with 2 agents and 2 items, 1 unallocated:\n  1 => {2}\n  2 => {}\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Allocation-Tuple{}","page":"Reference","title":"Allocations.Allocation","text":"Allocation()\n\nConstruct an empty allocation with zero agents and items.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Category","page":"Reference","title":"Allocations.Category","text":"mutable struct Category\n\nOne of the categories in a Counts constraint, from which each agent can hold at most a given number of items. The category supports iteration (over its members), and the threshold is available through the threshold attribute.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Conflicts","page":"Reference","title":"Allocations.Conflicts","text":"struct Conflicts{T <: AbstractGraph} <: Constraint\n\nA kind of constraint – or set of constraints – that indicates that certain items conflict, and thus cannot be allocated to the same agent. The constraints are represented as a conflict graph (Graphs.AbstractGraph), with items as nodes, and edges representing conflicts. The Conflicts type is just a wrapper for dispatch purposes, with the underlying graph available through the graph attribute.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Constraint","page":"Reference","title":"Allocations.Constraint","text":"abstract type Constraint <: Any\n\nAbstract supertype of various kinds of constraints. An instance of the allocation problem is assumed to consist of a Profile object and at most one Constraint object, embodying any and all constraints placed on feasible solutions.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Constraints","page":"Reference","title":"Allocations.Constraints","text":"struct Constraints{T <: Tuple{Vararg{Constraint}}} <: Constraint\n\nA thin wrapper around a tuple of constraints, acting as a single, combined constraint. May be constructed with a single tuple argument, or with zero or more Constraint objects. Its meaning is the conjunction of its constituent parts. That is, an allocation that is to satisfy Constraints(A, B) would need to satisfy both A and B. The wrapped tuple is available via the parts attribute.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Counts","page":"Reference","title":"Allocations.Counts","text":"struct Counts{T} <: Constraint\n\nThe cardinality constraints used by Biswas and Barman in their 2018 paper Fair Division Under Cardinality Constraints. This is a form of constraint consisting of several Category objects, available through indexing or iteration. Any agent may hold at most a given number of items from any given category.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Counts-Tuple{Vararg{Pair}}","page":"Reference","title":"Allocations.Counts","text":"Counts(args::Pair...)\n\nCreate a Counts object where each pair x => k becomes a category with members Set(x) and threshold k.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Forbidden","page":"Reference","title":"Allocations.Forbidden","text":"struct Forbidden{T} <: Constraint\n\nAn exclusion constraint, which specifies objects that agents are forbidden from receiving. These object sets are simply specified by an Allocation (or an Allocation-like object), provided to the constructor.\n\nThis constraint is asymmetric (see Symmetry).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.OrderedCategory","page":"Reference","title":"Allocations.OrderedCategory","text":"mutable struct OrderedCategory\n\nUsed in place of Category when handling an ordered instance. The instance is assumed to be such that items in the range index:index + n_items - 1 belong to the given category, i.e., the items of a category occupy a contiguous range of integers.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Permitted","page":"Reference","title":"Allocations.Permitted","text":"struct Permitted{T} <: Constraint\n\nA constraint that specifies objects that agents are permitted to receive, implicitly forbidding all others (cf. Forbidden). These object sets are simply specified by an Allocation (or an Allocation-like object), provided to the constructor.\n\nThis constraint is asymmetric (see Symmetry).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Profile","page":"Reference","title":"Allocations.Profile","text":"abstract type Profile <: Any\n\nAn abstract type representing an valuation profile. Which functions are used to query it depends on the kind of valuation functions it represents. Additive valuations act on individual objects, and simply sum those values over a bundle, but profiles with quite different kinds of queries are possible for valuations with other properties (see, e.g., Fair Allocation of Indivisible Goods: Improvements and Generalizations by Ghodsi et al., 2018).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Profile-Tuple{Matrix}","page":"Reference","title":"Allocations.Profile","text":"Profile(X::Matrix)\n\nAlias for Additive(X).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Reduction","page":"Reference","title":"Allocations.Reduction","text":"mutable struct Reduction{S, T, I, G}\n\nA reduction from one instance of a fair allocation problem to another. Contains information about the profiles in the reduced instance, through an object of type S. There must exist functions agents(s::S) and items(s::S) that return iterators of, respectively, the agents and items in the reduced instance. The reduction can also contain information about the constraints in the reduced instance, through an object of type T.\n\nIn addition, the reduction contains two mappings (vectors), λi (of type I) and λg (of type G). Both types should be indexable (for i ∈ agents(s) and g ∈ items(s), respectively). λi[i] and λg[g] should return the agent and item identifier in the original instance of, respectively, agent i and item g in the reduced instance.\n\nThe reduction also contains a function that can convert an allocation in the reduced instance to one in the original instance.\n\nThe default constructor is Reduction(V, C, λi, λg, transform::Function), for a profile V and constraint C.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Reduction-NTuple{4, Any}","page":"Reference","title":"Allocations.Reduction","text":"Reduction(V, λi, λg, transform)\n\nA simplified constructor for when there are no constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Reduction-Tuple{Any, Any}","page":"Reference","title":"Allocations.Reduction","text":"Reduction(V, C)\n\nA simplified constructor for when either no changes have been performed or changes only concern the profiles and/or constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Reduction-Tuple{Any}","page":"Reference","title":"Allocations.Reduction","text":"Reduction(V)\n\nA simplified constructor for when either no changes have been performed or changes only concern the profiles.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Reduction-Tuple{Reduction, Any}","page":"Reference","title":"Allocations.Reduction","text":"Reduction(R::Reduction, C)\n\nA simplified constructor to create a copy of a reduction with constraints attached.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Required","page":"Reference","title":"Allocations.Required","text":"struct Required{T} <: Constraint\n\nAn inclusion constraint, which specifies objects that agents are required to receive. These object sets are simply specified by an Allocation (or an Allocation-like object), provided to the constructor.\n\nThis constraint is asymmetric (see Symmetry).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Submodular","page":"Reference","title":"Allocations.Submodular","text":"struct Submodular <: Profile\n\nA submodular valuation profile, representing how each agent values all possible bundles. The profile is constructed from a set of n submodular valuation functions, one per agent, as well as the number of items, m. The profile functions should, when supplied with a Set of items (a subset of 1:m), return the value of that set of items to the given agent (i.e., acting as so-called query oracles).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Symmetry","page":"Reference","title":"Allocations.Symmetry","text":"Symmetry(instance)\nSymmetry(T::Type)\n\nIndicate whether a constraint instance or type is symmetric or asymmetric (indicated by a return value of Symmetric() or Asymmetric(), where Symmetric and Asymmetric are empty concrete subtypes of Symmetry). A symmetric constraint is one that is invariant under permutation of the agents, while an asymmetric constraint is not. That is, an asymmetric constraint is one that permits individual variations in the constraints placed on the bundles of different agents.\n\nAn instance has the same asymmetry as its type, and by default, this is Symmetric().\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.agent-Tuple{Reduction, Any}","page":"Reference","title":"Allocations.agent","text":"agent(R::Reduction, i)\n\nConverts the agent identifier i from the reduced instance to the agent identifier of the same agent in the original instance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.agents-Tuple{Any}","page":"Reference","title":"Allocations.agents","text":"agents(X)\n\nReturns the set of agents associated with (e.g., profile or allocation) X), as an iterable of Ints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.bundle-Tuple{Any, Any}","page":"Reference","title":"Allocations.bundle","text":"bundle(A, i)\n\nThe set of items allocated to agent i in the allocation A. The returned Set should be treated as read-only.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.ceil_n-Tuple{OrderedCategory, Any}","page":"Reference","title":"Allocations.ceil_n","text":"ceil_n(c::OrderedCategory, n)\n\nOne nth of the number of items in the category, rounded up.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.chain-Tuple{Reduction, Reduction}","page":"Reference","title":"Allocations.chain","text":"chain(R₁::Reduction, R₂::Reduction)\n\nAssumes that R₂ is a reduction of the reduced instance of R₁. Combines the two reductions, so that the original instance is the original instance of R₁ and the reduced instance is the reduced instance of R₂ (essentially diagram-order composition of the reductions).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.deny!-Tuple{Any, Any, Any}","page":"Reference","title":"Allocations.deny!","text":"deny!(A, i, g)\n\nDeny agent i the object g, which it has previously been given, in the allocation A.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.fill_even!-Tuple{Any}","page":"Reference","title":"Allocations.fill_even!","text":"fill_even!(A)\n\nFill out the allocation by distributing the unallocated items evenly, by repeatedly giving the next unallocated item to the agent with the fewest items (ties broken arbitrarily).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.fill_random!-Tuple{Any}","page":"Reference","title":"Allocations.fill_random!","text":"fill_random!(A)\n\nFill out the allocation by distributing the unallocated items randomly.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.floor_n-Tuple{OrderedCategory, Any}","page":"Reference","title":"Allocations.floor_n","text":"floor_n(c::OrderedCategory, n)\n\nOne nth of the number of items in the category, rounded down.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.give!-Tuple{Any, Any, Any}","page":"Reference","title":"Allocations.give!","text":"give!(A, i, B)\n\nGive agent i the bundle B in the Allocation A.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.give!-Tuple{Any, Any, Int64}","page":"Reference","title":"Allocations.give!","text":"give!(A, i, g::Int)\n\nGive agent i the object g in the Allocation A.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.isintegral","page":"Reference","title":"Allocations.isintegral","text":"isintegral(V::Profile)\n\nTest whether every value provided by V is an integer.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.isnonnegative","page":"Reference","title":"Allocations.isnonnegative","text":"isnonnegative(V::Profile)\n\nTest whether every value provided by V is nonnegative.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.item-Tuple{Reduction, Any}","page":"Reference","title":"Allocations.item","text":"item(R::Reduction, g)\n\nConverts the item identifier g from the reduced instance to the item identifier of the same item in the original instance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.items-Tuple{Any}","page":"Reference","title":"Allocations.items","text":"items(X)\n\nReturns the set of items associated with (e.g., profile or allocation) X, as an iterable of Ints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.matrix-Tuple{Additive}","page":"Reference","title":"Allocations.matrix","text":"matrix(V::Additive)\n\nReturn the underlying valuation matrix of V.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.matrix-Tuple{Profile}","page":"Reference","title":"Allocations.matrix","text":"matrix(V::Profile)\n\nReturn a matrix X where X[i, g] is value(V, i, g). May not be very useful in general (especially if calculating single-item values isn't efficient to begin with), but if such a matrix is available as part of the profile implementation (as with Additive), it may be returned directly.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.na","page":"Reference","title":"Allocations.na","text":"na(X)\n\nThe number of agents represented by (e.g., profile or allocation) X.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.ni","page":"Reference","title":"Allocations.ni","text":"ni(X)\n\nThe number of items represented by (e.g., profile or allocation) X.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.normalize-Tuple{Additive}","page":"Reference","title":"Allocations.normalize","text":"normalize(V::Additive)\n\nScale the values of V such that v_i(M) = n for all agents i.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.owned-Tuple{Any, Any}","page":"Reference","title":"Allocations.owned","text":"owned(A, g)\n\nWhether or not the item g is owned by any agent in the allocation A.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.owner-Tuple{Any, Any}","page":"Reference","title":"Allocations.owner","text":"owner(A, g)\n\nThe agent to which item g has been allocated in the allocation A. Will produce an error if g has been allocated to more than one agent.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.owners-Tuple{Any, Any}","page":"Reference","title":"Allocations.owners","text":"owners(A, g)\n\nThe set of agents to which item g has been allocated in the allocation A. The returned Set should be treated as read-only.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.required-Tuple{OrderedCategory, Any}","page":"Reference","title":"Allocations.required","text":"required(c::OrderedCategory, n)\n\nThe number of items the next agent must take in order to keep the instance valid, i.e., for there to be a maximum of (n - 1) * threshold remaining items.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.transform-Tuple{Reduction, Allocation}","page":"Reference","title":"Allocations.transform","text":"transform(R::Reduction, A::Allocation)\n\nConverts the given allocation for the reduced instance to one for original instance. The way the convertion occurs depends on the given reduction.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.value","page":"Reference","title":"Allocations.value","text":"value(V::Profile, i, S)\nvalue(V::Profile, i, g::Int)\n\nThe value agent i places on bundle S, according to the profile V. The second form is a shortcut for value(V, i, [g]); the shortcut will generally be more efficient. Note that the value of S may not in general be the sum of the values of its items; that property is unique to Additive profiles.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.value!-Tuple{Additive, Any, Any, Any}","page":"Reference","title":"Allocations.value!","text":"value!(V::Additive, i, g::Int, v)\n\nSet the value of item g, according to agent i, to v in profile V.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.value-Tuple{Additive, Any, Int64}","page":"Reference","title":"Allocations.value","text":"value(V::Additive, i, g::Int)\n\nThe value of item g, according to agent i under valuation profile V.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.value-Tuple{Profile, Any, Allocation}","page":"Reference","title":"Allocations.value","text":"value(V::Profile, i, A::Allocation)\n\nThe value agent i receives in allocation A, under the profile V.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.value-Union{Tuple{T}, Tuple{Additive, Any, T}} where T<:(AbstractMatrix)","page":"Reference","title":"Allocations.value","text":"value(V::Additive, i, A::T) where {T <: AbstractMatrix}\n\nSimilar to the case where A is an Allocation, except the allocation is expressed as a binary matrix, where A[i, g] indicates whether i has item g (1) or not (0). May also be used, e.g., with a matrix of variable references, when constructing MIPs with JuMP.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.value_1","page":"Reference","title":"Allocations.value_1","text":"value_1(V::Profile, i, S)\n\nThe value agent i places on bundle S, up to one item, that is, the smallest value i can place on bundle S after removing (at most) one item, according to the profile V.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.value_x","page":"Reference","title":"Allocations.value_x","text":"value_x(V::Profile, i, S)\n\nThe value agent i places on bundle S, up to any item, that is, the largest value i can place on bundle S after removing one item (or no items, if the bundle is empty), according to the profile V.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.copy-Tuple{Allocation}","page":"Reference","title":"Base.copy","text":"copy(A::Allocation)\n\nCreates a new allocation that has the same agents, items and bundles as A.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Checks-and-measures","page":"Reference","title":"Checks and measures","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Allocations]\nPages = [\"checks.jl\", \"measures.jl\"]","category":"page"},{"location":"reference/#Allocations.check","page":"Reference","title":"Allocations.check","text":"check(V, A, C)\n\nCheck that the allocation A obeys the Constraint C, given the profile V.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.check-Tuple{Any, Any, Conflicts}","page":"Reference","title":"Allocations.check","text":"check(V, A, C::Conflicts)\n\nCheck whether the allocation A respects the item conflicts C.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.check-Tuple{Any, Any, Counts}","page":"Reference","title":"Allocations.check","text":"check(V, A, C::Counts)\n\nCheck whether the allocation A respects the cardinality constraints C.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.check-Tuple{Any, Any, Nothing}","page":"Reference","title":"Allocations.check","text":"check(V, A, C::Nothing)\n\nTrivial check that A satisfies a null-constraint. Always returns true.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.check_complete-Tuple{Any}","page":"Reference","title":"Allocations.check_complete","text":"check_complete(A)\n\nCheck that the allocation is complete, or effective, in the sense that each item has been allocated to at least one agent.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.check_ef-Tuple{Any, Any}","page":"Reference","title":"Allocations.check_ef","text":"check_ef(V, A)\n\nCheck whether the allocation A is envy-free for the profile V, i.e., if no agent strictly prefers another agent's bundle.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.check_ef1-Tuple{Any, Any}","page":"Reference","title":"Allocations.check_ef1","text":"check_ef1(V, A)\n\nCheck whether the allocation A is envy-free up to one item for the profile V, i.e., if no agent strictly prefers another agent's bundle, given that an appropriate (e.g., the most valuable) item is removed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.check_efx-Tuple{Any, Any}","page":"Reference","title":"Allocations.check_efx","text":"check_efx(V, A)\n\nCheck whether the allocation A is envy-free up to any item for the profile V, i.e., if no agent strictly prefers another agent's bundle, given that an appropriate (e.g., the least valuable) item is removed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.check_partition-Tuple{Any}","page":"Reference","title":"Allocations.check_partition","text":"check_partition(A)\n\nCheck that the allocation is a partition, i.e., that each item has been allocated to exactly one agent.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.nash_welfare-Tuple{Any, Any}","page":"Reference","title":"Allocations.nash_welfare","text":"nash_welfare(V, A; nonzero=true)\n\nCompute the Nash welfare of the allocation A, given the profile V, i.e., the product of the individual agent utilities resulting from A. The nonzero keyword indicates that agents with a utility of zero are left out. If no agents with nonzero utility exist, the result is zero. To avoid overflow with large utilities, the product is performed using floating-point arithmetic, even if the utilities are integral.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.prop_alpha-Tuple{Any, Any}","page":"Reference","title":"Allocations.prop_alpha","text":"prop_alpha(V, A)\n\nCompute the fraction of proportionality guaranteed to every agent, that is, what fraction each agent is guaranteed to get of 1/n of their value for the grand bundle M.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.utility-Tuple{Any, Any}","page":"Reference","title":"Allocations.utility","text":"utility(V, A)\n\nCompute the utilitarian welfare of the allocation A, given the profile V, i.e., the sum of the individual agent utilities (i.e., the bundle values) resulting from A.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocation-algorithms","page":"Reference","title":"Allocation algorithms","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Allocations]\nPages = [\"algorithms.jl\"]","category":"page"},{"location":"reference/#Allocations.alloc_bb18_3-Tuple{Additive, Counts}","page":"Reference","title":"Allocations.alloc_bb18_3","text":"alloc_bb18_3(V::Additive, C::Counts; a=3, ghss18_4b_warn=true)\n\nThe 1/3-approximate MMS-allocation under cardinality constraints algorithm (Section 5) described by Biswas and Barman in their 2018 paper Fair Division Under Cardinality Constraints. Finds a 1/3-approximate MMS allocation for an instance of the fair allocation problem under cardinality constraints by converting the additive instance under cardinality constraints to a submodular instance without cardinality constraints. The allocation is then found by using the method of Ghodsi et al. (alloc_ghss18_4b), with possible reallocation of items to satisfy the constraints. Both keyword arguments, a and ghss18_4b_warn, are passed directly to alloc_ghss18_4b as respectively the keyword arguments a and x_warn. See alloc_ghss18_4b for documentation on how to use them.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_bkv18_1-Tuple{Any}","page":"Reference","title":"Allocations.alloc_bkv18_1","text":"alloc_bkv18_1(V; randpri=true)\n\nThe first algorithm (Alg-Identical) described by Barman, Krishnamurty and Vaish in their 2018 paper Greedy Algorithms for Maximizing Nash Social Welfare. The algorithm finds a 1.061-approximate MNW allocation when agents have identical valuations, i.e., for any agents i, j and item g, value(V, i, g) == value(V, j, g). (This approximation ratio applies to the geometric mean of agent utilities, not the raw product.) The result will also be envy-free up to any item (EFX).\n\nThe algorithm follows a straightforward greedy allocation procedure, where in each iteration, the most valuable item is allocated to the agent with the lowest utility. By default, ties are broken by giving the agents random priorities; if randpri is set to false, they are instead broken lexicographically (as specified by Barman et al.), so that the agent with the lower index is preferred.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_bkv18_2-Tuple{Any}","page":"Reference","title":"Allocations.alloc_bkv18_2","text":"alloc_bkv18_2(V; randpri=true, complete=false)\nalloc_hpps20_1(V; randpri=true, complete=false) # alias\n\nThe second algorithm (Alg-Binary) described by Barman, Krishnamurty and Vaish in their 2018 paper Greedy Algorithms for Maximizing Nash Social Welfare. The algorithm finds MNW allocations in polynomial time for binary additive valuations, i.e., where each agent values any given object at 0 or 1 (e.g., an Additive{BitMatrix}). It also works in a more general setting, where value(V, i, S), for any given i, is a concave function of the number of items g in S for which value(V, i, g) == 1.\n\nThe original algorithm builds on an initial allocation, but does not specify what this allocation should be. It also does not deal with the case where one or more agents ends up with zero utility; in fact the procedure will not work even if we start with two or more agents with zero utility in the intial allocation. The strategy followed here is the same as that of Caragiannis et al., where a maximum cardinality set of agents achieving positive utility is found using bipartite matching (with no fairness considerations). The remaining items are randomly allocated to agents among these that value them, if any. Remaining agents and items are ignored by the procedure.\n\nFollowing the algorithm of Barman et al., the tie-breaking procedure (Algorithm 1) of Halpern et al. is used, where the MNW allocation is transformed into the lexicographically greatest MNW, according to some ordering of the agents, providing group-strategyproofness (GSP) in addition to the EF1 and PO guarantees that follow from MNW. By default, the agent ordering/priority is random; if this randomization is turned off (with randpri set to false), the default ordering is used, with agent 1 receiving the highest priority, etc.\n\nnote: Note\nDespite the use of randomization here, by default, this is the deterministic procedure of Halpern et al. They also describe a randomized procedure, which functions in an entirely different manner.\n\nFinally, if the complete argument is set to true, the allocation is completed with fill_even! (which means that some agents that must necessarily get a utility of zero can still receive items valued zero, if that evens out the bundle cardinalities). Note that this undermines the GSP guarantee, which requires that these items be discarded. The return value is a named tuple with the fields alloc (the Allocation) and mnw (the Nash welfare, ignoring agents with zero utility).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_ghss18_4-Tuple{Submodular, Any}","page":"Reference","title":"Allocations.alloc_ghss18_4","text":"alloc_ghss18_4(V::Submodular, MMSs)\n\nThe fourth algorithm (Algorithm 4) described by Ghodsi et al. in the 2018 paper Fair allocation of Indivisible Goods: Improvements and Generalizations. The algorithm finds a 1/3-approximate MMS allocation for a given submodular instance and corresponding maximin shares for the agents (MMSs[i] should be the MMS of agent i). If the supplied maximin shares, are higher than the actual maximin shares, the method may fail. In that case, this will be indicated in the result, where res.fail will be set to true and res.agent will be set to the agent last considered when the method failed to improve. If the maximin shares are unknown, use alloc_ghss18_4b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_ghss18_4b-Tuple{Submodular}","page":"Reference","title":"Allocations.alloc_ghss18_4b","text":"alloc_ghss18_4b(V::Submodular; a=3, x_warn=true)\n\nA variation on the fourth algorithm (Algorithm 4) described by Ghodsi et al. in the 2018 paper Fair allocation of Indivisible Goods: Improvements and Generalizations. The algorithm finds a 1/3-approximate MMS allocation for a given submodular instance. The method starts by overestimating the MMS of each agent and slowly decreasing the MMS of specific agents until alloc_ghss18_4 returns an allocation.\n\nThe amount that the MMS of an agent should be reduced by in each iteration is not specified by Ghodsi et al. One can show that if the factor is 1/(1 + 1/x), where x ≥ 3n - 1, then the algorithm will successfully find a 1/3-approximate MMS allocation. One way to show this, is to modify Lemma 4.6 in their paper to assume that each of the bundles Sᵢ is valued at least 1/(1 + 1/x). Using this modified version of Lemma 4.6, one can modify the proof of Theorem 4.7 to show that as long as x ≥ 3n - 1, the change in expectance from moving an item is at least 1/(3m). The value of x used in this implementation is x = an, where the keyword argument a is set to 3 by default (i.e., x = 3n). If a is set so that x < 3n - 1 a warning will be given. The warning can be turned off by setting x_warn to false.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_gmt18-Tuple{Additive}","page":"Reference","title":"Allocations.alloc_gmt18","text":"alloc_gmt18(V)\n\nThe 2/3-approximate MMS allocation algorithm described by Garg, McGlaughlin and Taki in their 2018 paper Approximating Maximin Share Allocations. The algorithm finds a 2/3-approximate MMS allocation for an instance with additive valuations. The algorithm works by performing a set of reductions to simplify the instance, limiting the maximum value of a good and the number of high-valued goods. The algorithm then uses bag-filling to allocate the remaining goods to the remaining agents.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_half_mms","page":"Reference","title":"Allocations.alloc_half_mms","text":"alloc_half_mms(V::Additive, C::Counts)\n\nFind a 1/2-approximate MMS allocation that obeys the constraints imposed by C. The allocation is found using alloc_hh22_1. See alloc_hh22_1 for a detailed description of how the method works.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.alloc_hh22_1-Tuple{Additive, Counts}","page":"Reference","title":"Allocations.alloc_hh22_1","text":"alloc_hh22_1(V::Additive, C::Counts; α=0.5)\n\nThe 1/2-approximate MMS allocation under cardinality constraints algorithm (Algorithm 3) described by Hummel and Hetland in their Maximin Shares Under Cardinality Constraints (2022). First the instance is reduced to an ordered normalized instance where each good is worth less than 1/2. While there are more than one agent remaining, the algorithm creates a bundle with the textcategoryn lowest-valued items in each category. Repeatedly, it converts each of these to the highest-valued remaining item in the category until it either runs out of items to convert or an agent values the bundle at least 1/2. If the procedure runs out of items to convert, it adds the highest-valued remaining item in each category, in order, to get textcategoryn items from each category.  After each such item is added, the value is again checked for each agent. Since the instance was ordered normalized and without items worth 1/2 or more, the bundle created will always be worth more than 1/2 to one of the remaining agents before the procedure runs out of items to add to it or convert from low- to high-valued.\n\nAnother approximation ratio, α, can be supplied. If α ≤ 0.5 the algorithm is guaranteed to succeed. Otherwise, the method will try to find an allocation with an approximation ratio of α, but may fail. In the latter case, the results will indicate a failure by setting res.fail to true.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_rand-Tuple{Any, Conflicts}","page":"Reference","title":"Allocations.alloc_rand","text":"alloc_rand(V, C::Conflicts)\n\nAllocate items to agents randomly, respecting the item conflicts. Uses the randomized coloring procedure with symmetry-breaking of Pemmaraju and Srinivasan, which works as follows:\n\nGive the items random priorities, corresponding to a permutation selected uniformly at ramdom.\nTentatively allocate each item randomly to an agent, without concern for the item conflicts.\nIf an agent has received conflicting items, it keeps the highest-priority item (i.e., earliest in the permutation), and the others are reallocated arbitrarily.\n\nThis final arbitrary reallocation is also performed randomly in this implementation, by going through the items in random order, allocating each to a randomly selected agent among those able to receive it.\n\nThe valuation profile V is not used, other than to determine the number of agents and items.\n\nFor this algorithm to function properly, the maximum degree of the conflict graph should be strictly less than the number of agents.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_rand-Tuple{Any}","page":"Reference","title":"Allocations.alloc_rand","text":"alloc_rand(V)\n\nA straightforward lottery that allocates the items randomly to the agents. For each item, its agent is selected uniformly at random. The valuation profile V is not used, other than to determine the number of agents and items. The return value is a named tuple with the field alloc (the Allocation).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_rand-Tuple{Int64, Int64, Conflicts}","page":"Reference","title":"Allocations.alloc_rand","text":"alloc_rand(n::Int, m::Int, C::Conflicts)\n\nSame as alloc_rand(V, C), for n agents and m items.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_rand-Tuple{Int64, Int64}","page":"Reference","title":"Allocations.alloc_rand","text":"alloc_rand(n::Int, m::Int)\n\nSame as alloc_rand(V), for n agents and m items.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Reductions","page":"Reference","title":"Reductions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Allocations]\nPages = [\"reductions.jl\"]","category":"page"},{"location":"reference/#Allocations.order-Tuple{Additive, Counts}","page":"Reference","title":"Allocations.order","text":"order(V::Additive, C::Counts)\n\nCreate an ordered instance for the given weights and categories. The items are reorded such that each category has a continous range of indices for its items. Returns a reduction, with a transformation that converts an allocation to one in the original instance where each agent gets at least the same value as in the ordered instance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.order-Tuple{Additive}","page":"Reference","title":"Allocations.order","text":"order(V::Additive)\n\nCreate an ordered instance for the given weights. The weights are reordered for each agent such that item 1 is worth the most and item m is worth the least. Returns new additive valuations and a function to convert an allocation in the ordered instance into one for the original instance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.reduceutil-Tuple{Profile, Vararg{Pair}}","page":"Reference","title":"Allocations.reduceutil","text":"reduceutil(V::Profile, assignments::Pair...)\n\nUtility function that given valuations and a collection of assignments of bundles to agents (i => B), creates a reduced instance, translation tables from the reduced instance and a function to convert an allocation in the reduced instance to one in the original instance – including the given assignements. The function returns a Reduction object without any constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.reducevaluation-Tuple{Additive, Any, Any}","page":"Reference","title":"Allocations.reducevaluation","text":"reducevaluation(V::Additive, λi, λg)\n\nUtility function that given additive valuations prior to a reduction and translation tables for the reduction, returns new additive valuations for the reduced instance. The new valuations are as prior to the reduction, except for missing items/agents and changes in item/agent numbers.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.reducevaluation-Tuple{Submodular, Any, Any}","page":"Reference","title":"Allocations.reducevaluation","text":"reducevaluation(V::Submodular, λi, λg)\n\nUtility function that given submodular valuations prior to a reduction and translation tables for the reduction, returns new submodular valuations for the reduced instance. The new valuations are as prior to the reduction, except for missing items/agents and changes in item/agent numbers. That is, the new valuation functions work by translating the item numbers to what they would be prior to the reduction and calling the valuation function of the agent prior to the reduction.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.revert-NTuple{4, Any}","page":"Reference","title":"Allocations.revert","text":"revert(λi, λg, assignments, A)\n\nConvert an allocation for a reduced instance to one for the original instance, including giving the removed bundles to the removed agents.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.revert-Tuple{Additive, Any}","page":"Reference","title":"Allocations.revert","text":"revert(V::Additive, A)\n\nConvert an allocation for the ordered instance to one for the original instance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.revert-Tuple{Additive, Counts, Counts, Any}","page":"Reference","title":"Allocations.revert","text":"revert(V::Additive, C::Counts, C′::Counts, A)\n\nConvert an allocation for the ordered instance (C′) to one for the original instance (V, C).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.reduce-Tuple{Additive, Counts{OrderedCategory}, Any, Any}","page":"Reference","title":"Base.reduce","text":"reduce(V::Additive, C::Counts{OrderedCategory}, i, B)\n\nReduce the instance given by the pair (V, C) to a new instance by giving the supplied agent, i, the supplied bundle, B. Returns a reduction, where the transformation, in addition to converting the allocation to one for the original instance, allocates B to i.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.reduce-Tuple{Additive, Counts{OrderedCategory}, Real}","page":"Reference","title":"Base.reduce","text":"reduce(V::Additive, C::Counts{OrderedCategory}, α)\n\nReduce an ordered instance by normalizing the values and giving any agent that value an individual item greater than or equal to α the item and any low value items required to reduce to a valid instance. This reduction is performed recursively until no more such items exist. The reduction does not decrease the MMS guarantee of any remaining agents and all agents that are allocated a bundle in the reduction is guaranteed to value their bundle at least α of their MMS guarantee.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.reduce-Tuple{Additive, Real}","page":"Reference","title":"Base.reduce","text":"reduce(V::Additive, α::Real; greedy::Bool=true)\n\nReduce an ordered instance by normalizing the values and giving any agent that value an individual item greater than or equal to α the item.  This reduction is performed recursively until no more such items exist. The reduction does not decrease the MMS guarantee of any remaining agents and all agents that are allocated a bundle in the reduction is guaranteed to value their bundle at least α of their MMS guarantee. The agent-item pairs are either selected greedily or by finding a maximum matching between agents and such items.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.reduce-Tuple{Additive, Vararg{Function}}","page":"Reference","title":"Base.reduce","text":"reduce(V::Additive, F::Function...)\n\nReduce an instance V by repeatedly applying the functions f ∈ F to find bundles to be allocated. The functions in F are expected to return either a pair, (i, B), consisting of an agent i and the bundle B to be assigned to agent i, or the value nothing if the function couldn't find a valid bundle-agent-pair. The functions are called in prioritized order and the instance is reduced and normalized between each invocation. The functions are invoked with the valuation matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.reduce-Tuple{Profile, Real}","page":"Reference","title":"Base.reduce","text":"reduce(V::Profile, α::Real)\n\nProduce a reduced instance by giving an item to any agent that values it at α or more. This reduction is performed repeatedly, until no such item exists.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.reduce-Tuple{Profile, Vararg{Pair}}","page":"Reference","title":"Base.reduce","text":"reduce(V::Valuation, assignment::Pair...)\n\nReduce the instance given to a new instance where the involved agents and bundles in the assignments are removed. Returns new valuations and a function that turns an allocation in the reduced instance into one for the original instance, including giving the supplied agent the supplied bundle.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.reduce-Tuple{Submodular, Any, Any}","page":"Reference","title":"Base.reduce","text":"reduce(V::Submodular, i, B)\n\nReduce the instance given by V to a new instance by giving the specified bundle, B, to agent i. Returns a reduction, where the transformation, in addition to converting the allocation to one for the original instance, allocates B to i.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIP-based","page":"Reference","title":"MIP-based allocation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Allocations]\nPages = [\"mip.jl\"]","category":"page"},{"location":"reference/#Allocations.alloc_ef1-Tuple{Any, Any}","page":"Reference","title":"Allocations.alloc_ef1","text":"alloc_ef1(V, C; solver=conf.MIP_SOLVER, kwds...)\n\nCreate an Allocation that is envy-free up to one item (EF1), based on the valuation profile V, possibly subject to the constraints given by the Constraint object C. The solution is found using a straightforward mixed-integer program, and is most suitable for constraints where no specialized algorithm exists. For example, without constraints, a straightforward round robin picking sequence yields EF1, and a similar strategy works for cardinality constraints. (It is still possible to use this function without constraints, by explicitly supplying nothing for the constraint argument C.) The return value is a named tuple with the fields alloc (the Allocation) and model (the JuMP model used in the computation).\n\nLower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments min_bundle, max_bundle, min_owners and max_owners, the latter two of which default to 1. If one of these is nothing, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.\n\nNote that for some constraints, there may not be an EF1 allocation, in which case the function will fail with an exception.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_efx","page":"Reference","title":"Allocations.alloc_efx","text":"alloc_efx(V[, C]; solver=conf.MIP_SOLVER, kwds...)\n\nCreate an Allocation that is envy-free up to any item (EFX), based on the valuation profile V, possibly subject to the constraints given by the Constraint object C. The solution is found using a straightforward mixed-integer program. The return value is a named tuple with the fields alloc (the Allocation) and model (the JuMP model used in the computation).\n\nLower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments min_bundle, max_bundle, min_owners and max_owners, the latter two of which default to 1. If one of these is nothing, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.\n\nNote that while some constraints may prevent an exact EFX allocation, it is currently (Mar 2021) an open question whether EFX always exists in the unconstrained case (see, e.g., Improving EFX Guarantees through Rainbow Cycle Number by Chaudhury et al.).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.alloc_ggi","page":"Reference","title":"Allocations.alloc_ggi","text":"alloc_ggi(V[, C]; wt=wt_gini, solver=conf.MIP_SOLVER, kwds...)\n\nMaximizes a generalized Gini index (GGI), also known as a generalized Gini social-evaluation functions. The function being maximized is an ordered weighted average (OWA) of agent utilities, utilities, where the weight is based on utility rank i, from the least happy (1) to the most happy (n), parameterized by the function wt(i, n). It is generally assumed that the weights are nondecreasing in i. Note that there is no need to use normalized weights (i.e., to produce a weighted average, despite the term OWA), as is often the case when such measures are used to measure inequality (e.g., by subtracting the OWA from an ordinary average, cf. Generalized gini inequality indices by John A. Weymark).\n\nThe default wt_gini gives the (non-normalized) weights of the original Gini social-evaluation. Two other notable cases for wt are (i, _) -> i == 1, which yields a maximin allocation, and (i, _) -> 1, which yields a purely utilitarian allocation (with no consideration for fairness). The solution method used is based on that of Lesca and Perny (linear formulation Pi_W) in their paper 2010 paper “LP Solvable Models for Multiagent Fair Allocation Problems”. The return value is a named tuple with the fields alloc (the Allocation that has been produced) and model (the JuMP model used in the computation).\n\nLower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments min_bundle, max_bundle, min_owners and max_owners, the latter two of which default to 1. If one of these is nothing, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.\n\nIn the original inequality measures, the mean agent utility is included as a normalizing term, which is harmless for the case of identical valuations functions (and when looking at, say, the distribution of incomes), but when valuations differ, this mean will vary with the allocations. As pointed out by Lesca and Perny, such a measure is not monotone with Pareto dominance – the optimization will tend to drive the mean utility down. Therefore only the term measuring (in)equality (i.e., the ordered weighted sum of agent utilities) is used.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.alloc_lmm","page":"Reference","title":"Allocations.alloc_lmm","text":"alloc_lmm(V[, C]; solver=conf.MIP_SOLVER, kwds...)\n\nCreate a lexicographic maximin (leximin) Allocation, i.e., one where the lowest bundle value is maximized, and subject to that, the second lowest is maximized, etc. The return value is a named tuple with fields alloc (the Allocation) and model (the JuMP model used in the computation).\n\nThe method used for leximin optimization is that of Ogryczak and Śliwiński (\"On Direct Methods for Lexicographic Min-Max Optimization\", 2006).\n\nLower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments min_bundle, max_bundle, min_owners and max_owners, the latter two of which default to 1. If one of these is nothing, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.alloc_mm","page":"Reference","title":"Allocations.alloc_mm","text":"alloc_mm(V[, C]; cutoff=nothing, ignored_agents=[],\n    solver=conf.MIP_SOLVER, kwds...)\n\nCreate an egalitarian or maximin Allocation, i.e., one where the minimum bundle value is maximized. The cutoff, if any, is a level at which we are satisfied, i.e., any allocation where all agents attain this value is acceptable. The return value is a named tuple with fields alloc (the Allocation), mm (the lowest agent utility) and model (the JuMP model used in the computation).\n\nThe ignored_agents argument indicates agents that should be ignored when maximizing the minimum. These agents may still receive items, and will participate in forming a feasible allocation (possibly with respect to some constraint C); they are only ignored in the objective.\n\nnote: Note\nMost users will probably not need ignored_agents. Its primary use is as part of alloc_mms, for ignoring agents with an MMS of zero, whose α is unbounded.\n\nLower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments min_bundle, max_bundle, min_owners and max_owners, the latter two of which default to 1. If one of these is nothing, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.alloc_mms","page":"Reference","title":"Allocations.alloc_mms","text":"alloc_mms(V[, C]; cutoff=false, solver=conf.MIP_SOLVER,\n          mms_kwds=(), kwds...)\n\nFind an MMS allocation, i.e., one that satisfies the maximin share guarantee, where each agent gets a bundle it weakly prefers to its maximin share (introduced by Budish, in his 2011 paper The Combinatorial Assignment Problem: Approximate Competitive Equilibrium from Equal Incomes). The return value is a named tuple with fields alloc (the Allocation), mmss, the individual MMS values for the instance, alpha, the lowest fraction of MMS that any agent achieves (is at least 1 exactly when the allocation is MMS), model (the JuMP model used in computing alpha) and mms_models (the JuMP models used to compute the individual maximin shares). If cutoff is set to true, this fraction is capped at 1.\n\nIf all agents have an MMS of zero, alpha will be unbounded, represented by the value Inf. This is the case even if one or more agents get a value of 0.\n\nLower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments min_bundle, max_bundle, min_owners and max_owners, the latter two of which default to 1. If one of these is nothing, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.\n\nWhen finding an MMS partition for each individual agent, the constraint and options act a little differently than when finding the actual allocation. If an asymmetric Constraint C is supplied (i.e., one that is different for the different agents), agent i's version is enforced on every bundle to determine which partitions are feasible.\n\nThe same holds for min_bundle and max_bundle. Apart from those two, the keywords kwds are also used for the MMS partitions.\n\ntip: Tip\nIn some cases, using asymmetric constraints might lead to a situation where a feasible allocation exists, but for some agent, an MMS partition does not. Then the agent's maximin share is undefined! One way around this is to relax the definition a bit, and to permit charity when finding the MMS partitions. The agent will still try to maximize the mininum value of any bundle in this partition, but is not required to allocate every object. This can be achieved as follows:alloc_mms(V, C, mms_kwds=(min_owner=0,))You should verify that the strategy makes sense for your application, however! In some cases, it might not be necessary, and would just needlessly inflate maximin shares. Also, it is only guaranteed to work for constraints where an empty bundle is feasible; it might fail for Required, for example. Indeed, for some constraints, one could argue that it might not be advisable to use the MMS criterion to begin with.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.alloc_mnw","page":"Reference","title":"Allocations.alloc_mnw","text":"alloc_mnw(V[, C]; mnw_warn=false, solver=conf.MIP_SOLVER, kwds...)\n\nCreate an Allocation attaining maximum Nash welfare (MNW), based on the valuation profile V, possibly subject to the constraints given by the Constraint object C. The solution is found using the approach of Caragiannis et al. in their 2019 paper The Unreasonable Fairness of Maximum Nash Welfare, with two minor modifications:\n\nRather than hard-coding a maximum valuation (arising from the assumption that the values of each agent sum to 1000), this maximum is extracted from V; and\nExtra constraints are permitted (through the object C), possibly lowering the attainable MNW.\n\nBecause of how the integer program is constructed, it may be affected by precision effects, where a high number of agents can make it impossible to guarantee Pareto optimalty (PO), EF1 or MNW. If the precision is too low, the appropriate warning will be issued, but the computation is not halted. Note that these warnings are quite conservative (see note below). This is particularly true of the one for MNW, which is disabled by default, in part because of its sensitivity, and in part because it will generally be useful to find solutions that satisfy PO and EF1, even if it may not be exactly MNW. The MNW warning can be enabled by setting the mnw_warn keyword to true.\n\nnote: Note\nThe warnings are based on the lower bounds described by Caragiannis et al. On the one hand, the bound is only used to test whether current floating-point precision is sufficient; any tolerance or gap used by the solver is not used, which might in principle mean that false negatives are possible. On the other hand, these bounds, especially the one for exact MNW, may in practice be quite loose, with small variations in agent utilities leading to large changes in objective value, unless the changes are finely tuned to cancel out.\n\nThe return value is a named tuple with fields alloc (the Allocation), mnw (the achieved Nash welfare for the agents with nonzero utility), mnw_prec (whether or not there was enough precision to satisfy the lower bound guaranteeing exact MNW) and model (the JuMP model used in the computation).\n\nLower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments min_bundle, max_bundle, min_owners and max_owners, the latter two of which default to 1. If one of these is nothing, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.alloc_mnw_ef1-Tuple{Any, Any}","page":"Reference","title":"Allocations.alloc_mnw_ef1","text":"alloc_mnw_ef1(V, C; mnw_warn=true, solver=conf.MIP_SOLVER, kwds...)\n\nEquivalent to alloc_mnw, except that EF1 is enforced. Without any added constraints, MNW implies EF1, so this function is not needed in that case. Therefore the argument C is not optional.\n\nLower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments min_bundle, max_bundle, min_owners and max_owners, the latter two of which default to 1. If one of these is nothing, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.mms","page":"Reference","title":"Allocations.mms","text":"mms(V::Additive, i[, C]; solver=conf.MIP_SOLVER, kwds...)\n\nDetermine the maximin share of agent i, i.e., the bundle value she is guaranteed to attain if she partitions the items and the other agents choose their bundles. Useful, e.g., as a point of reference when determining the empirical approximation ratios of approximate MMS allocation algorithms. Also used as a subroutine in alloc_mms. The return value is a named tuple with the fields mms (the maximin share of agent i) and model (the JuMP model used in the computation).\n\nLower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments min_bundle, max_bundle, min_owners and max_owners, the latter two of which default to 1. If one of these is nothing, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.\n\nIf a constraint C is supplied, and this is asymmetric (i.e., different for the different agents), agent i's version is enforced on every bundle to determine which partitions are feasible.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.mms_alpha-Tuple{Any, Any, Any}","page":"Reference","title":"Allocations.mms_alpha","text":"mms_alpha(V, A, mmss)\n\nUtility function to find the fraction of the maximin share guarantee attained by the allocation A, under the valuation profile V, where mmss[i] is the MMS of agent i. This makes it possible, for example, to use the mmss field from the result of alloc_mms to find the MMS approximation provided by an allocation constructed by other means. For example:\n\nmmss = alloc_mms(V).mmss\nA = alloc_rand(V).alloc\nalpha = mms_alpha(V, A, mmss)\n\nIf all agents have an MMS of zero, alpha will be unbounded, represented by the value Inf. This is the case even if one or more agents get a value of 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.wt_gini-Tuple{Any, Any}","page":"Reference","title":"Allocations.wt_gini","text":"wt_gini(i, n)\n\nThe (unnormalized) weights used in the ordered weighted average in the Gini social-evaluation function, where the utility of the ith agent, ordered by increasing utility, is given weight 2(n - i) + 1. (The normalized weights yielding the original Gini social-evaluation function are divided by n^2, but this makes no difference to the optimization problem.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Instance-generation","page":"Reference","title":"Instance generation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Allocations]\nPages = [\"data.jl\"]","category":"page"},{"location":"reference/#Allocations.rand_additive-Tuple{}","page":"Reference","title":"Allocations.rand_additive","text":"rand_additive(; n=2:10, m=n->2n:4n, v=(n, m)->Uniform(), rng=default_rng())\nrand_profile(; n=2:10, m=n->2n:4n, v=(n, m)->Uniform(), rng=default_rng())\n\nGenerate a random additive valuation profile (an Additive object) with the number of agents and items, agents and values chosen using rand with the given values as the first argument. Here n is used directly, while m should be a function of the number of agents, which returns an argument for rand. Similarly, v should be a function of both the number of agents and items.\n\nThe defaults for n and m are taken from Hummel and Hetland, who based them on based on real-world data from Caragiannis et al., with n at most 10, and the average m/n approximately 3.\n\nThe distribution for the values can be univariate, in which case it is used independently for each value. For example, to generate Gaussian valuations, with the Distributions package, use v=(n, m)->Normal().\n\nHowever, it can also be multivariate, in which case each sample should be a vector of the same length as the number of items, representing the valuation function of a single agent. For example, to get a Dirichlet distribution, where an agent's values sum to 1, you could use v=(n, m)->Dirichlet(m, 2).\n\nIt is also possible to use a matrix-variate distribution, such as a matrix normal distribution, where each sample should then be an m by n matrix, with each column representing the valuation function of a single agent.\n\nwarning: Warning\nNote that the matrix samples should be the transpose of the ones used in the resulting profile. This is to maintain consistency with the multivariate distributions, which produce column vectors.\n\nrand_profile is an alias for rand_additive.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.rand_conflicts_ba02-Tuple{Any}","page":"Reference","title":"Allocations.rand_conflicts_ba02","text":"rand_conflicts_ba02(m; k=1:m, rng=default_rng())\nrand_conflicts_ba02(V::Profile; ...)\n\nGenerate a random Conflicts contraint, whose underlying graph is constructed according to the Barabási–Albert model. The keyword argument k specifies the possible values for the corresponding parameter k, which is generated using rand.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.rand_conflicts_er59","page":"Reference","title":"Allocations.rand_conflicts_er59","text":"rand_conflicts_er59(m, p=Uniform(), rng=default_rng())\nrand_conflicts_er59(V::Profile; ...)\nrand_conflicts(m; ...)\nrand_conflicts(m::Profile; ...)\n\nGenerate a random Conflicts contraint, whose underlying graph is constructed according to the Erdős–Rényi model. The keyword argument p specifies the possible values for the corresponding parameter p, which is generated using rand.\n\nrand_conflicts is an alias for rand_conflicts_er59.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.rand_conflicts_ws98-Tuple{Any}","page":"Reference","title":"Allocations.rand_conflicts_ws98","text":"rand_conflicts_ws98(m; k=2:2:div(m, 2), β=Uniform(), rng=default_rng())\nrand_conflicts_ws98(V::Profile; ...)\n\nGenerate a random Conflicts contraint, whose underlying graph is constructed according to the Watts–Strogatz model. The keyword arguments k and β specify the possible values for the corresponding parameters k and beta, which are generated using rand. The defaults are taken from Hummel and Hetland. Note that the parameter k should be an even number, which Watts and Strogatz assume to be much smaller than m.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Configuration","page":"Reference","title":"Configuration","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Allocations]\nPages = [\"conf.jl\"]","category":"page"},{"location":"reference/#Allocations.conf","page":"Reference","title":"Allocations.conf","text":"conf\n\nA struct with fields for global configuration of the Allocations module.\n\nFields\n\nMIP_SOLVER::Any\n\nThe (factory for the) JuMP optimizer to be used (by default) for mixed-integer programming. Initially set to HiGHS.Optimizer, with log_to_console set to false. This can be overridden either by setting MIP_SOLVER to another value (e.g., using the JuMP function optimizer_with_attributes) or by passing the solver directly to the appropriate allocation functions.\n\nMIP_SUCCESS::Any\n\nContainer of acceptable MIP statuses. By default, has the value [MOI.OPTIMAL].\n\n\n\n\n\n","category":"constant"},{"location":"#Allocations.jl","page":"Allocations.jl","title":"Allocations.jl","text":"","category":"section"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"CurrentModule = Allocations","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"The Allocations package deals with the fair allocation of indivisible items to a set of agents. An instance of this problem consists of:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"A set N of n agents and a set M of m items;\nOne valuation function v_i2^MtoR for each agent iin N;","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"For simplicity, we may simply let N=1dotsn and M=1dotsm.[1]","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"[1]: The latter is less common, presumably because the two sets then intersect. An alternative is to let M be a set of opaque objects g_j, for j=1dots m.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"The goal is to find an allocation A=(A_1dotsA_n), which gives a bundle A_isubseteq M to each agent, and which satisfies certain fairness criteria. The allocation is usually required to form a partition of M, though in some scenarios, one may deviate from this.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"In Allocations.jl, an instance is represented by the valuation profile V=v_iiin N, in the form of a Profile object. Given a profile V, the various parts of the instance may be accessed as follows:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"items(V): The item set N, as an iterable;\nagents(V): The agent set M, as an iterable;\nvalue(V, i, S): The value agent i assigns to the set Ssubseteq M, i.e., v_i(S).","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"S may be any iterable. If it a single item (i.e., Int) g, it is interpreted as a singleton, [g] (though usually handled more efficiently). The number of agents and items, respectively, are found using na(V) and ni(V)","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"In addition to this basic setting, instances may be constrained, by supplying some constraint object, describing which bundles are feasible. For example, if one is looking for bundles that are connected in some sense, the constraint object will typically be a graph that defines the connectivity relation, etc.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Allocations are represented by Allocation objects. Given an allocation A, the bundle of agent i is found using bundle(A, i).","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"tip: Tip\nFor more on this topic, see, e.g., the Wikipedia entry on fair item allocation, or the surveys by Amanatidis et al. and Suksompong, on the unconstrained and constrained versions of the problem, respectively.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"In classical fair division, the resources being allocated are assumed to be divisible, and in some recent work, a mixture of divisible and indivisible resources is permitted. The Allocations package does not support this directly, but you can approximately represent a divisible resource as a set of indivisible ones. For example, you could follow the strategy used by Spliddit, and divide such resources into 100 pieces, giving each piece 1% of the original value.","category":"page"},{"location":"#Installation","page":"Allocations.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"To install the package, you can simply import it in the Julia REPL:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"julia> using Allocations","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Press enter at the resulting prompt to install both the package and its dependencies.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"To install a more recent version than the released one, you can use the package manager directly. In the Julia REPL, press ] to enter the Pkg REPL, and then add the package directly from the source:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"pkg> add https://github.com/mlhetland/Allocations.jl","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"You can then import the module as before.","category":"page"},{"location":"#Basic-use","page":"Allocations.jl","title":"Basic use","text":"","category":"section"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"To specify an allocation problem instance, create a valuation profile:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"julia> V = Profile([1 2 3; 2 3 1])\nAdditive{Matrix{Int64}} with 2 agents and 3 items:\n 1  2  3\n 2  3  1","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Profile is an abstract class, and Profile(X::Matrix) is an alias for Additive(X). Once you have a valuation profile, you can use an allocation function (ones called alloc_...), e.g., for finding a maximum Nash welfare (MNW) allocation:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"julia> res = alloc_mnw(V);","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Note that the first time you call an allocation function, it may take some time to finish, because there's quite a lot of compilation going on behind the scenes. From then on, in the same REPL session, there will be much less overhead.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"These functions take a Profile as input and return a named tuple with the field alloc referring to an Allocation:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"julia> A = res.alloc\nAllocation with 2 agents and 3 items:\n  1 => {3}\n  2 => {1, 2}","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"The bundle of each agent is available through the bundle function:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"julia> bundle(A, 2)\nSet{Int64} with 2 elements:\n  2\n  1","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Bundles should not be modified directly, as the Allocation also maintains an inverse mapping, from items to agents. Rather, use the give! and deny! functions.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Some allocation functions may produce other results as well, such as properties of the allocation that are naturally computed as part of the allocation process. For the MNW case, the objective value (the Nash welfare, which is being maximized) is available as mnw:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"julia> res.mnw\n15.0","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"The allocation functions also permit a matrix argument as a shortcut, implicitly creating an Additive. For example, you can find a maximin share (MMS) allocation as follows:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"julia> alloc_mms([1 1 2 3; 2 1 2 3]).alloc\nAllocation with 2 agents and 4 items:\n  1 => {2, 3}\n  2 => {1, 4}","category":"page"},{"location":"#Constraints","page":"Allocations.jl","title":"Constraints","text":"","category":"section"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"In constrained fair allocation, extra criteria determine which allocations are allowed, or feasible. Such constraints could, in principle, designate any class of allocations as feasible, but the most common scenario is that the constraints is only concerned with bundles, i.e., which bundles are feasible, individually.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"note: Note\nOne example of a different kind of constraint is that of Gourvès and Monnot, who permit partial allocations, but require the set of allocated items to be a basis of a given matroid.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"In the Allocations package, constrained instances are represented by a valuation Profile along with a single Constraint object. (If one wishes to combine constraints, this can be achieved using the Constraints type.) For example, one might use a graph to indicate items that are in conflict, and cannot be allocated to the same agent:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"julia> using Graphs\n\njulia> V = Additive([1 1 0; 0 0 2])\nAdditive{Matrix{Int64}} with 2 agents and 3 items:\n 1  1  0\n 0  0  2\n\njulia> G = path_graph(3)\n{3, 2} undirected simple Int64 graph\n\njulia> alloc_mnw(V, Conflicts(G)).alloc\nAllocation with 2 agents and 3 items:\n  1 => {2}\n  2 => {1, 3}","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"In this example, agent 1 wants the first two items, while agent 2 want the third. Allocating accordingly would provide a perfectly fair distribution, with identical utility for both agents. However, our conflict graph—a path of length 3—tells us that no agent can have both items 1 and 2 (nor both 2 and 3). Our only choice, then (to avoid a Nash welfare of zero) is for the second agent to get the first and third items.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"For an overview of several types of constraints (some of which are implemented by the Allocations library), see, e.g., the survey by Suksompong.","category":"page"},{"location":"#Symmetry","page":"Allocations.jl","title":"Symmetry","text":"","category":"section"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"We call a constraint symmetric in the agents (or simply symmetric) if the set of feasible bundles is the same for all agents. This is the most common case, though there are exceptions. For example, Dror et al. let agents have different matroid constraints, and with so-called budget constraints, the agents may have different budgets. The Permitted, Forbidden and Required constraints are also asymmetric, in general.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"For many purposes, symmetry makes no difference. One important exception is finding MMS-allocations. For symmetric constraints (and in the unconstrained case), an agent's maximin share (MMS) is the greatest value she can get if she gets the worst bundle in a feasible partition of the items, and an MMS allocation is one where each agent gets her MMS.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"If the constraint is asymmetric, however, this definition of MMS might not make sense. The idea is that the agent partitions the items, and then gets to choose last—i.e., gets the worst bundle, according to her. However, different constraints apply to the different bundles, she could find a partition where she isn't permitted the worst bundle, for example. There are several ways of approaching this situation (e.g., enforcing the agent's constraint in addition to the other agents' bundles, or making sure the worst bundle is feasible for the agent in question).","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Our (default) approach is to assume that the partitioning agent doesn't know which bundles the others would choose. She doesn't know their constraints, and so cannot apply them, and she doesn't know which bundle will be left for her, so she must apply her constraint to every bundle. In other words, finding the MMS becomes a maximin allocation problem where both the valuation function and the constraint of the agent in question is replicated, creating n \"clone agents\". (For symmetric constraints, this is, of course, equivalent to the standard approach.)","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"The discrepancy in constraints between finding the MMS of each agent and finding an MMS allocation means that we can have situations where feasible allocations exist, but the MMS of one or more agents is not defined (because no feasible MMS partition exists). Because the duplicated constraints here represent the agent's ability to receive any of the bundles in the partition, and not the actual feasibility of the partition as an allocation, one strategy is to permit leaving some items out (cf. the next section) when finding the MMS partitions. See alloc_mms for more on this.","category":"page"},{"location":"#generalized","page":"Allocations.jl","title":"Generalized allocations","text":"","category":"section"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Ordinarily, an allocation is assumed to be a partition of the items being allocated, with each item belonging to exactly one agent. Allocation objects, however, are capable of representing more general forms of allocations, where each item can belong to an arbitrary subset of the agents:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"julia> A = Allocation(1 => 1, 2 => 1, 2 => 3)\nAllocation with 2 agents and 3 items, 1 unallocated:\n  1 => {1}\n  2 => {1, 3}","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"For methods relying on a mixed-integer programming solver, such generalized allocations may be permitted by using the keyword arguments min_bundle, max_bundle, min_owners and max_owners (as described in the documentation of each method).","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Allocating items to multiple agents is relevant, for example, in scenarios like reviewing papers for an academic conference (as discussed by Lesca and Perny), or, perhaps, allocating shifts to workers. Such scenarios can generally also be represented by duplicating the items, and adding a cardinality constraint, permitting each agent at most one copy of any item.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Allowing some items to remain unallocated (often thought of as being given to charity) can make a big difference to the problem being solved. Some constraints may make it impossible to allocate all the items. For example, if a conflict graph with a high maximum degree is imposed, it may simply be impossible to allocate all items (cf. Hummel and Hetland). If the feasible bundles of any agent form an independence system (i.e., an empty bundle is feasible, and adding items can never repair an infeasible bundle), permitting charity ensures that an allocation is always possible.[2]","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"[2]: The same is true of envy-based measures such as EFX, which may not always exist even for unconstrained instances. (This is an open question at the time of writing.)","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"When allocating goods with fairness criteria that maximize efficiency in some way (such as leximin, MNW or GGI), there will be a tendency towards not needlessly leaving items to charity. For purely envy-based criteria, however (such as EF1 or EFX), one might in principle end up satisfying the criterion by simply not allocating anything. In these cases, it might be better to combine with an efficiency optimization (such as, e.g., alloc_mnw_ef1).","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Maximin and MMS are in a special position, here, in that they may leave items unallocated unnecessarily (i.e., not forced by a constraint), but simply distributing these items arbitrarily will not affect the validity of the solution. If, for some reason, charity were permitted with any of these in an unconstrained setting, any remaining items could simply be distributed using fill_random! or fill_even!.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"note: Note\nIf you use maximin or MMS with a constraint, distributing any leftover items is generally intractable, and probably best handled by the same solver that found the allocation to begin with. For maximin, you might consider simply switching to leximin (which will also return a maximin allocation).[3]","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"[3]: For MMS, there is currently no ready-made solution to ensure efficiency, though one could, for example, perform a two-step optimization (along the lines of lex_optimize!, found in util.jl). First, one would use alloc_mms and mms_alpha to find the MMS values of all agents and the proportion of the MMS guarantee attainable, and then one would add the appropriate constraints to ensure this proportion while maximizing some efficiency measure, e.g., the sum of utilities.","category":"page"},{"location":"#Solver-configuration","page":"Allocations.jl","title":"Solver configuration","text":"","category":"section"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Several allocation functions use mixed-integer linear programming via JuMP. Depending on the choice of MIP solver, solving even moderately-sized instances may take a significant amount of time. Choosing a different solver (from the default HiGHS.Optimizer) may speed things up considerably. For example, with the appropriate license, one could use use Gurobi as follows:[4]","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"[4]: If you're a student or a researcher, Gurobi is available for free under an academic license.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Allocations.conf.MIP_SOLVER = Gurobi.Optimizer","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"It is also possible to supply the Optimizer (or other optimizer factories, e.g., constructed using optimizer_with_attributes) as the solver keyword argument to the relevant allocation functions.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Normally, the MIP solvers will print out quite a lot of information about what they're doing. If you're not interested in this output, you can generally turn it off using some solver-specific flag, supplied to optimizer_with_attributes.[5] This is also where you'd supply other parameters, e.g., indicating time limits, acceptable inaccuracies, etc. For example:[6]","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"[5]: There is also the JuMP.set_silent function, but it requires access to the MIP model.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"[6]: See the Gurobi manual for explanations.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Allocations.conf.MIP_SOLVER = optimizer_with_attributes(\n    Gurobi.Optimizer,\n    \"LogToConsole\" => 0,     # No console output\n    \"TimeLimit\" => 60,       # Finish within 60 seconds\n    \"MipGap\" => 0.05,        # Permit 5% suboptimality\n)","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"If you're unable to get rid of the output using solver parameters, a simple solution is to just silence all output while allocating:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"julia> redirect_stdout(devnull) do\n           alloc_mnw(V)\n       end","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"If that doesn't do the trick, you could add redirect_stderr as well.","category":"page"}]
}
