var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = Allocations","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Function naming: Allocation functions that use a straightforward procedure, or simply use a solver to enforce some property, are named after that procedure or property (such as alloc_rand or alloc_ef1). For published algorithms, the package uses a naming scheme based on the original publication.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"The root of the function name is alloc_, followed by a publication code:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"For a single-author paper, the first three letters of the author's last name are used;\nfor multi-author papers, the first letter of the first four authors are concatenated.\nTo this, the last two digits of the year are added.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"For example, the 2/3-MMS algorithm of Garg, McGlaughlin and Taki (2018) is implemented by alloc_gmt18.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"If the same code applies to multiple publications, they are distinguished by a suffix a, b, etc., after the year digits.\nIf a single publication discusses multiple algorithms, a number such as _1, _2, etc., is added. So, for example, the third algorithm described by Biswas and Barman (2018) is alloc_bb18_3.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Some functions (such as alloc_hh22_1) are given generic names as aliases (in this case, alloc_half_mms).","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"note: Note\nThese publication codes are similar to the authorship trigraphs used in some citation styles. Specifically, they follow the conventions of alpha.bst, except that an \"et al.\" character is not added when there are five or more authors.","category":"page"},{"location":"reference/#Basic-types","page":"Reference","title":"Basic types","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Allocations]\nPages = [\"types.jl\"]","category":"page"},{"location":"reference/#Allocations.Additive","page":"Reference","title":"Allocations.Additive","text":"struct Additive{T <: AbstractMatrix} <: Profile\n\nAn additive valuation profile, representing how each agent values all possible bundles. Because of additivity, this is easily \"lifted\" from the values of individual items, by addition, with an empty bundle given a value of zero. By default, the profile is constructed from a real matrix X, supplied to the default constructor, where X[i, g] is agent i's value for item g.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Additive-Tuple{Any, Any}","page":"Reference","title":"Allocations.Additive","text":"Additive(n, m)\n\nCreate an additive profile for n agents and m items where all values are set to zero.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Allocation","page":"Reference","title":"Allocations.Allocation","text":"struct Allocation <: Any\n\nA mapping A from agents i to their assigned bundles bundle(A, i). Agents and items are represented as Ints, and bundles as Sets of Ints. The Allocation also maintains an inverse mapping, from items g to their set of owners, owners(A, g). To keep these in sync, the bundles should be modified using give! and deny!, rather than altering the bundle sets directly.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Allocation-Tuple{Int64, Int64}","page":"Reference","title":"Allocations.Allocation","text":"Allocation(n::Int, m::Int)\n\nConstruct an empty allocation with n agents and m items.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Allocation-Tuple{Profile}","page":"Reference","title":"Allocations.Allocation","text":"Allocation(V::Profile)\n\nConstruct an empty allocation with a number of agents and items equal to that of the instance (i.e., profile) V.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Allocation-Tuple{}","page":"Reference","title":"Allocations.Allocation","text":"Allocation()\n\nConstruct an empty allocation with zero agents and items.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Category","page":"Reference","title":"Allocations.Category","text":"mutable struct Category\n\nOne of the categories in a Counts constraint, from which each agent can hold at most a given number of items. The category supports iteration (over its members), and the threashold is available through the threshold accessor.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Conflicts","page":"Reference","title":"Allocations.Conflicts","text":"struct Conflicts{T <: AbstractGraph} <: Constraint\n\nA kind of constraint – or set of constraints – that indicates that certain items conflict, and thus cannot be allocated to the same agent. The constraints are represented as a conflict graph (Graphs.AbstractGraph), with items as nodes, and edges representing conflicts. The Conflicts type is just a wrapper for dispatch purposes, with the underlying graph available through the graph accessor.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Constraint","page":"Reference","title":"Allocations.Constraint","text":"abstract type Constraint <: Any\n\nAbstract supertype of various kinds of constraints. An instance of the allocation problem is assumed to consist of a Profile object and at most one Constraint object, embodying any and all constraints placed on feasible solutions.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Counts","page":"Reference","title":"Allocations.Counts","text":"struct Counts{T} <: Constraint\n\nThe cardinality constraints introduced by Biswas and Barman in their 2018 paper Fair Division Under Cardinality Constraints. This is a form of constraint consisting of several Category objects, available through indexing or iteration. Any agent may hold at most a given number of items from any given category.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Counts-Tuple{Vararg{Pair}}","page":"Reference","title":"Allocations.Counts","text":"Counts(args::Pair...)\n\nCreate a Counts object where each pair x => k becomes a category with members Set(x) and threshold k.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.OrderedCategory","page":"Reference","title":"Allocations.OrderedCategory","text":"mutable struct OrderedCategory\n\nUsed in place of Category when handling an ordered instance. The instance is assumed to be such that items in the range index:index + n_items - 1 belong to the given category, i.e., the items of a category occupy a contiguous range of integers.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Profile","page":"Reference","title":"Allocations.Profile","text":"abstract struct Profile <: Any\n\nAn abstract type representing an valuation profile. Which functions are used to query it depends on the kind of valuation functions it represents. Additive valuations act on individual objects, and simply sum those values over a bundle, but profiles with quite different kinds of queries are possible for valuations with other properties (see, e.g., Fair Allocation of Indivisible Goods: Improvements and Generalizations by Ghodsi et al., 2018).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Profile-Tuple{Matrix}","page":"Reference","title":"Allocations.Profile","text":"Profile(X::Matrix)\n\nAlias for Additive(X).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Reduction","page":"Reference","title":"Allocations.Reduction","text":"mutable struct Reduction{S, T, U, V}\n\nA reduction from one instance of a fair allocation problem to another. Contains information about the profiles in the reduced instance, through an object of type S. There must exist functions agents(s::S) and items(s::S) that return iterators of, respectively, the agents and items in the reduced instance. The reduction can also contain information about the constraints in the reduced instance, through an object of type T.\n\nIn addition, the reduction contains two mappings (vectors), λi (of type I) and λg (of type G). Both types should be indexable (for i ∈ agents(s) and g ∈ items(s), respectively). λi[i] and λg[g] should return the agent and item identifier in the original instance of, respectively, agent i and item g in the reduced instance.\n\nThe reduction also contains a function that can convert an allocation in the reduced instance to one in the original instance.\n\nThe default constructor is Reduction(V, C, λi, λg, transform::Function).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.Reduction-NTuple{4, Any}","page":"Reference","title":"Allocations.Reduction","text":"Reduction(V, λi, λg, transform)\n\nA simplified constructor for when there are no constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Reduction-Tuple{Any, Any}","page":"Reference","title":"Allocations.Reduction","text":"Reduction(V, C)\n\nA simplified constructor for when either no changes have been performed or changes only concern the profiles and/or constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Reduction-Tuple{Any}","page":"Reference","title":"Allocations.Reduction","text":"Reduction(V)\n\nA simplified constructor for when either no changes have been performed or changes only concern the profiles.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Reduction-Tuple{Reduction, Any}","page":"Reference","title":"Allocations.Reduction","text":"Reduction(R::Reduction, C)\n\nA simplified constructor to create a copy of a reduction with constraints attached.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.Submodular","page":"Reference","title":"Allocations.Submodular","text":"struct Submodular <: Profile\n\nA submodular valuation profile, representing how each agent values all possible bundles. The profile is constructed from a set of n submodular valuation functions, one per agent, as well as the number of items, m. The profile functions should, when supplied with a Set of items (a subset of 1:m), return the value of that set of items to the given agent (i.e., acting as so-called query oracles).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Allocations.agent-Tuple{Reduction, Any}","page":"Reference","title":"Allocations.agent","text":"agent(R::Reduction, i)\n\nConverts the agent identifier i from the reduced instance to the agent identifier of the same agent in the original instance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.agents-Tuple{Any}","page":"Reference","title":"Allocations.agents","text":"agents(X)\n\nReturns the set of agents associated with (e.g., profile or allocation) X), as an iterable of Ints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.bundle-Tuple{Any, Any}","page":"Reference","title":"Allocations.bundle","text":"bundle(A, i)\n\nThe set of items allocated to agent i in the allocation A. The returned Set should be treated as read-only.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.ceil_n-Tuple{OrderedCategory, Any}","page":"Reference","title":"Allocations.ceil_n","text":"ceil_n(c::OrderedCategory, n)\n\nOne nth of the number of items in the category, rounded up.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.chain-Tuple{Reduction, Reduction}","page":"Reference","title":"Allocations.chain","text":"chain(R₁::Reduction, R₂::Reduction)\n\nAssumes that R₂ is a reduction of the reduced instance of R₁. Combines the two reductions, so that the original instance is the original instance of R₁ and the reduced instance is the reduced instance of R₂ (essentially diagram-order composition of the reductions).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.constraint-Tuple{Reduction}","page":"Reference","title":"Allocations.constraint","text":"constraint(R::Reduction)\n\nReturns the constraint object for the reduced instance\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.deny!-Tuple{Any, Any, Any}","page":"Reference","title":"Allocations.deny!","text":"deny!(A, i, g)\n\nDeny agent i the object g, which it has previously been given, in the allocation A.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.fill_even!-Tuple{Any}","page":"Reference","title":"Allocations.fill_even!","text":"fill_even!(A)\n\nFill out the allocation by distributing the unallocated items evenly, by repeatedly giving the next unallocated item to the agent with the fewest items (ties broken arbitrarily).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.fill_random!-Tuple{Any}","page":"Reference","title":"Allocations.fill_random!","text":"fill_random!(A)\n\nFill out the allocation by distributing the unallocated items randomly.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.floor_n-Tuple{OrderedCategory, Any}","page":"Reference","title":"Allocations.floor_n","text":"floor_n(c::OrderedCategory, n)\n\nOne nth of the number of items in the category, rounded down.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.give!-Tuple{Any, Any, Any}","page":"Reference","title":"Allocations.give!","text":"give!(A, i, B)\n\nGive agent i the bundle B in the Allocation A.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.give!-Tuple{Any, Any, Int64}","page":"Reference","title":"Allocations.give!","text":"give!(A, i, g::Int)\n\nGive agent i the object g in the Allocation A.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.graph-Tuple{Conflicts}","page":"Reference","title":"Allocations.graph","text":"graph(C::Conflicts)\n\nReturn the conflict graph wrapped by a Conflicts object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.isintegral","page":"Reference","title":"Allocations.isintegral","text":"isintegral(V::Profile)\n\nTest whether every value provided by V is an integer.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.isnonnegative","page":"Reference","title":"Allocations.isnonnegative","text":"isnonnegative(V::Profile)\n\nTest whether every value provided by V is nonnegative.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.item-Tuple{Reduction, Any}","page":"Reference","title":"Allocations.item","text":"item(R::Reduction, g)\n\nConverts the item identifier g from the reduced instance to the item identifier of the same item in the original instance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.items-Tuple{Any}","page":"Reference","title":"Allocations.items","text":"items(X)\n\nReturns the set of items associated with (e.g., profile or allocation) X, as an iterable of Ints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.matrix-Tuple{Additive}","page":"Reference","title":"Allocations.matrix","text":"matrix(V::Additive)\n\nReturn the underlying valuation matrix of V.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.matrix-Tuple{Profile}","page":"Reference","title":"Allocations.matrix","text":"matrix(V::Profile)\n\nReturn a matrix X where X[i, g] is value(V, i, g). May not be very useful in general (especially if calculating single-item values isn't efficient to begin with), but if such a matrix is available as part of the profile implementation (as with Additive), it may be returned directly.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.na","page":"Reference","title":"Allocations.na","text":"na(X)\n\nThe number of agents represented by (e.g., profile or allocation) X.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.ni","page":"Reference","title":"Allocations.ni","text":"ni(X)\n\nThe number of items represented by (e.g., profile or allocation) X.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.normalize-Tuple{Additive}","page":"Reference","title":"Allocations.normalize","text":"normalize(V::Additive)\n\nScale the values of V such that v_i(M) = n for all agents i.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.owned-Tuple{Any, Any}","page":"Reference","title":"Allocations.owned","text":"owned(A, g)\n\nWhether or not the item g is owned by any agent in the allocation A.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.owner-Tuple{Any, Any}","page":"Reference","title":"Allocations.owner","text":"owner(A, g)\n\nThe agent to which item g has been allocated in the allocation A. Will produce an error if g has been allocated to more than one agent.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.owners-Tuple{Any, Any}","page":"Reference","title":"Allocations.owners","text":"owners(A, g)\n\nThe set of agents to which item g has been allocated in the allocation A. The returned Set should be treated as read-only.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.profile-Tuple{Reduction}","page":"Reference","title":"Allocations.profile","text":"profile(R::Reduction)\n\nReturns the valuation profile for the reduced instance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.required-Tuple{OrderedCategory, Any}","page":"Reference","title":"Allocations.required","text":"required(c::OrderedCategory, n)\n\nThe number of items the next agent must take in order to keep the instance valid, i.e., for there to be a maximum of (n - 1) * threshold remaining items.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.threshold-Tuple{Allocations.Category}","page":"Reference","title":"Allocations.threshold","text":"threshold(c::Category)\n\nThe maximum number of items any agent can receive from the given category, as part of a Counts constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.transform-Tuple{Reduction, Allocation}","page":"Reference","title":"Allocations.transform","text":"transform(R::Reduction, A::Allocation)\n\nConverts the given allocation for the reduced instance to one for original instance. The way the convertion occurs depends on the given reduction.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.value","page":"Reference","title":"Allocations.value","text":"value(V::Profile, i, S)\nvalue(V::Profile, i, g::Int)\n\nThe value agent i places on bundle S, according to the profile V. The second form is a shortcut for value(V, i, [g]); the shortcut will generally be more efficient. Note that the value of S may not in general be the sum of the values of its items; that property is unique to Additive profiles.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.value!-Tuple{Additive, Any, Any, Any}","page":"Reference","title":"Allocations.value!","text":"value!(V::Additive, i, g::Int, v)\n\nSet the value of item g, according to agent i, to v in profile V.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.value-Tuple{Additive, Any, Int64}","page":"Reference","title":"Allocations.value","text":"value(V::Additive, i, g::Int)\n\nThe value of item g, according to agent i under valuation profile V.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.value-Tuple{Profile, Any, Allocation}","page":"Reference","title":"Allocations.value","text":"value(V::Profile, i, A::Allocation)\n\nThe value agent i receives in allocation A, under the profile V.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.value_1","page":"Reference","title":"Allocations.value_1","text":"value_1(V::Profile, i, S)\n\nThe value agent i places on bundle S, up to one item, that is, the smallest value i can place on bundle S after removing (at most) one item, according to the profile V.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.value_x","page":"Reference","title":"Allocations.value_x","text":"value_x(V::Profile, i, S)\n\nThe value agent i places on bundle S, up to any item, that is, the largest value i can place on bundle S after removing one item (or no items, if the bundle is empty), according to the profile V.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Checks-and-measures","page":"Reference","title":"Checks and measures","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Allocations]\nPages = [\"checks.jl\", \"measures.jl\"]","category":"page"},{"location":"reference/#Allocations.check","page":"Reference","title":"Allocations.check","text":"check(V, A, C)\n\nCheck that the allocation A obeys the Constraint C, given the profile V.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.check-Tuple{Any, Any, Conflicts}","page":"Reference","title":"Allocations.check","text":"check(V, A, C::Conflicts)\n\nCheck whether the allocation A respects the item conflicts C.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.check-Tuple{Any, Any, Counts}","page":"Reference","title":"Allocations.check","text":"check(V, A, C::Counts)\n\nCheck whether the allocation A respects the cardinality constraints C.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.check_complete-Tuple{Any}","page":"Reference","title":"Allocations.check_complete","text":"check_complete(A)\n\nCheck that the allocation is complete, or effective, in the sense that each item has been allocated to at least one agent.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.check_ef-Tuple{Any, Any}","page":"Reference","title":"Allocations.check_ef","text":"check_ef(V, A)\n\nCheck whether the allocation A is envy-free for the profile V, i.e., if no agent strictly prefers another agent's bundle.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.check_ef1-Tuple{Any, Any}","page":"Reference","title":"Allocations.check_ef1","text":"check_ef1(V, A)\n\nCheck whether the allocation A is envy-free up to one item for the profile V, i.e., if no agent strictly prefers another agent's bundle, given that an appropriate (e.g., the most valuable) item is removed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.check_efx-Tuple{Any, Any}","page":"Reference","title":"Allocations.check_efx","text":"check_efx(V, A)\n\nCheck whether the allocation A is envy-free up to any item for the profile V, i.e., if no agent strictly prefers another agent's bundle, given that an appropriate (e.g., the least valuable) item is removed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.check_partition-Tuple{Any}","page":"Reference","title":"Allocations.check_partition","text":"check_partition(A)\n\nCheck that the allocation is a partition, i.e., that each item has been allocated to exactly one agent.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.nash_welfare-Tuple{Any, Any}","page":"Reference","title":"Allocations.nash_welfare","text":"nash_welfare(V, A; nonzero=true)\n\nCompute the Nash welfare of the allocation A, given the profile V, i.e., the product of the individual agent utilities resulting from A. The nonzero keyword indicates that agents with a utility of zero are left out. If no agents with nonzero utility exist, the result is zero. To avoid overflow with large utilities, the product is performed using floating-point arithmetic, even if the utilities are integral.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.prop_alpha-Tuple{Any, Any}","page":"Reference","title":"Allocations.prop_alpha","text":"prop_alpha(V, A)\n\nCompute the fraction of proportionality guaranteed to every agent, that is, what fraction each agent is guaranteed to get of 1/n of their value for the grand bundle M.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.utility-Tuple{Any, Any}","page":"Reference","title":"Allocations.utility","text":"utility(V, A)\n\nCompute the utilitarian welfare of the allocation A, given the profile V, i.e., the sum of the individual agent utilities (i.e., the bundle values) resulting from A.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocation-algorithms","page":"Reference","title":"Allocation algorithms","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Allocations]\nPages = [\"algorithms.jl\"]","category":"page"},{"location":"reference/#Allocations.alloc_bb18_3-Tuple{Additive, Counts}","page":"Reference","title":"Allocations.alloc_bb18_3","text":"alloc_bb18_3(V::Additive, C::Counts; a=3, ghss18_4b_warn=true)\n\nThe 1/3-approximate MMS-allocation under cardinality constraints algorithm (Section 5) described by Biswas and Barman in their 2018 paper Fair Division Under Cardinality Constraints. Finds a 1/3-approximate MMS allocation for an instance of the fair allocation problem under cardinality constraints by converting the additive instance under cardinality constraints to a submodular instance without cardinality constraints. The allocation is then found by using the method of Ghodsi et al. (alloc_ghss18_4b), with possible reallocation of items to satisfy the constraints. Both keyword arguments, a and ghss18_4b_warn, are passed directly to alloc_ghss18_4b as respectively the keyword arguments a and x_warn. See alloc_ghss18_4b for documentation on how to use them.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_bkv18_1-Tuple{Any}","page":"Reference","title":"Allocations.alloc_bkv18_1","text":"alloc_bkv18_1(V; randpri=true)\n\nThe first algorithm (Alg-Identical) described by Barman, Krishnamurty and Vaish in their 2018 paper Greedy Algorithms for Maximizing Nash Social Welfare. The algorithm finds a 1.061-approximate MNW allocation when agents have identical valuations, i.e., for any agents i, j and item g, value(V, i, g) == value(V, j, g). (This approximation ratio applies to the geometric mean of agent utilities, not the raw product.) The result will also be envy-free up to any item (EFX).\n\nThe algorithm follows a straightforward greedy allocation procedure, where in each iteration, the most valuable item is allocated to the agent with the lowest utility. By default, ties are broken by giving the agents random priorities; if randpri is set to false, they are instead broken lexicographically (as specified by Barman et al.), so that the agent with the lower index is preferred.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_bkv18_2-Tuple{Any}","page":"Reference","title":"Allocations.alloc_bkv18_2","text":"alloc_bkv18_2(V; randpri=true, complete=false)\nalloc_hpps20_1(V; randpri=true, complete=false) # alias\n\nThe second algorithm (Alg-Binary) described by Barman, Krishnamurty and Vaish in their 2018 paper Greedy Algorithms for Maximizing Nash Social Welfare. The algorithm finds MNW allocations in polynomial time for binary additive valuations, i.e., where each agent values any given object at 0 or 1 (e.g., an Additive{BitMatrix}). It also works in a more general setting, where value(V, i, S), for any given i, is a concave function of the number of items g in S for which value(V, i, g) == 1.\n\nThe original algorithm builds on an initial allocation, but does not specify what this allocation should be. It also does not deal with the case where one or more agents ends up with zero utility; in fact the procedure will not work even if we start with two or more agents with zero utility in the intial allocation. The strategy followed here is the same as that of Caragiannis et al., where a maximum cardinality set of agents achieving positive utility is found using bipartite matching (with no fairness considerations). The remaining items are randomly allocated to agents among these that value them, if any. Remaining agents and items are ignored by the procedure.\n\nFollowing the algorithm of Barman et al., the tie-breaking procedure (Algorithm 1) of Halpern et al. is used, where the MNW allocation is transformed into the lexicographically greatest MNW, according to some ordering of the agents, providing group-strategyproofness (GSP) in addition to the EF1 and PO guarantees that follow from MNW. By default, the agent ordering/priority is random; if this randomization is turned off (with randpri set to false), the default ordering is used, with agent 1 receiving the highest priority, etc.\n\nnote: Note\nDespite the use of randomization here, by default, this is the deterministic procedure of Halpern et al. They also describe a randomized procedure, which functions in an entirely different manner.\n\nFinally, if the complete argument is set to true, the allocation is completed with fill_even! (which means that some agents that must necessarily get a utility of zero can still receive items valued zero, if that evens out the bundle cardinalities). Note that this undermines the GSP guarantee, which requires that these items be discarded. The return value is a named tuple with the fields alloc (the Allocation) and mnw (the Nash welfare, ignoring agents with zero utility).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_ghss18_4-Tuple{Submodular, Any}","page":"Reference","title":"Allocations.alloc_ghss18_4","text":"alloc_ghss18_4(V::Submodular, MMSs)\n\nThe fourth algorithm (Algorithm 4) described by Ghodsi et al. in the 2018 paper Fair allocation of Indivisible Goods: Improvements and Generalizations. The algorithm finds a 1/3-approximate MMS allocation for a given submodular instance and corresponding maximin shares for the agents (MMSs[i] should be the MMS of agent i). If the supplied maximin shares, are higher than the actual maximin shares, the method may fail. In that case, this will be indicated in the result, where res.fail will be set to true and res.agent will be set to the agent last considered when the method failed to improve. If the maximin shares are unknown, use alloc_ghss18_4b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_ghss18_4b-Tuple{Submodular}","page":"Reference","title":"Allocations.alloc_ghss18_4b","text":"alloc_ghss18_4b(V::Submodular; a=3, x_warn=true)\n\nA variation on the fourth algorithm (Algorithm 4) described by Ghodsi et al. in the 2018 paper Fair allocation of Indivisible Goods: Improvements and Generalizations. The algorithm finds a 1/3-approximate MMS allocation for a given submodular instance. The method starts by overestimating the MMS of each agent and slowly decreasing the MMS of specific agents until alloc_ghss18_4 returns an allocation.\n\nThe amount that the MMS of an agent should be reduced by in each iteration is not specified by Ghodsi et al. One can show that if the factor is 1/(1 + 1/x), where x ≥ 3n - 1, then the algorithm will successfully find a 1/3-approximate MMS allocation. One way to show this, is to modify Lemma 4.6 in their paper to assume that each of the bundles Sᵢ is valued at least 1/(1 + 1/x). Using this modified version of Lemma 4.6, one can modify the proof of Theorem 4.7 to show that as long as x ≥ 3n - 1, the change in expectance from moving an item is at least 1/(3m). The value of x used in this implementation is x = an, where the keyword argument a is set to 3 by default (i.e., x = 3n). If a is set so that x < 3n - 1 a warning will be given. The warning can be turned off by setting x_warn to false.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_gmt18-Tuple{Additive}","page":"Reference","title":"Allocations.alloc_gmt18","text":"alloc_gmt18(V)\n\nThe 2/3-approximate MMS allocation algorithm described by Garg, McGlaughlin and Taki in their 2018 paper Approximating Maximin Share Allocations. The algorithm finds a 2/3-approximate MMS allocation for an instance with additive valuations. The algorithm works by performing a set of reductions to simplify the instance, limiting the maximum value of a good and the number of high-valued goods. The algorithm then uses bag-filling to allocate the remaining goods to the remaining agents.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_half_mms","page":"Reference","title":"Allocations.alloc_half_mms","text":"alloc_half_mms(V::Additive, C::Counts)\n\nFind a 1/2-approximate MMS allocation that obeys the constraints imposed by C. The allocation is found using alloc_hh22_1. See alloc_hh22_1 for a detailed description of how the method works.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.alloc_hh22_1-Tuple{Additive, Counts}","page":"Reference","title":"Allocations.alloc_hh22_1","text":"alloc_hh22_1(V::Additive, C::Counts; α=0.5)\n\nThe 1/2-approximate MMS allocation under cardinality constraints algorithm (Algorithm 3) described by Hummel and Hetland in their Maximin Shares Under Cardinality Constraints (2022). First the instance is reduced to an ordered normalized instance where each good is worth less than 1/2. While there are more than one agent remaining, the algorithm creates a bundle with the textcategoryn lowest-valued items in each category. Repeatedly, it converts each of these to the highest-valued remaining item in the category until it either runs out of items to convert or an agent values the bundle at least 1/2. If the procedure runs out of items to convert, it adds the highest-valued remaining item in each category, in order, to get textcategoryn items from each category.  After each such item is added, the value is again checked for each agent. Since the instance was ordered normalized and without items worth 1/2 or more, the bundle created will always be worth more than 1/2 to one of the remaining agents before the procedure runs out of items to add to it or convert from low- to high-valued.\n\nAnother approximation ratio, α, can be supplied. If α ≤ 0.5 the algorithm is guaranteed to succeed. Otherwise, the method will try to find an allocation with an approximation ratio of α, but may fail. In the latter case, the results will indicate a failure by setting res.fail to true.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_rand-Tuple{Any, Conflicts}","page":"Reference","title":"Allocations.alloc_rand","text":"alloc_rand(V, C::Conflicts)\n\nAllocate items to agents randomly, respecting the item conflicts. Uses the randomized coloring procedure with symmetry-breaking of Pemmaraju and Srinivasan, which works as follows:\n\nGive the items random priorities, corresponding to a permutation selected uniformly at ramdom.\nTentatively allocate each item randomly to an agent, without concern for the item conflicts.\nIf an agent has received conflicting items, it keeps the highest-priority item (i.e., earliest in the permutation), and the others are reallocated arbitrarily.\n\nThis final arbitrary reallocation is also performed randomly in this implementation, by going through the items in random order, allocating each to a randomly selected agent among those able to receive it.\n\nThe valuation profile V is not used, other than to determine the number of agents and items.\n\nFor this algorithm to function properly, the maximum degree of the conflict graph should be strictly less than the number of agents.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_rand-Tuple{Any}","page":"Reference","title":"Allocations.alloc_rand","text":"alloc_rand(V)\n\nA straightforward lottery that allocates the items randomly to the agents. For each item, its agent is selected uniformly at random. The valuation profile V is not used, other than to determine the number of agents and items. The return value is a named tuple with the field alloc (the Allocation).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_rand-Tuple{Int64, Int64, Conflicts}","page":"Reference","title":"Allocations.alloc_rand","text":"alloc_rand(n::Int, m::Int, C::Conflicts)\n\nSame as alloc_rand(V, C), for n agents and m items.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_rand-Tuple{Int64, Int64}","page":"Reference","title":"Allocations.alloc_rand","text":"alloc_rand(n::Int, m::Int)\n\nSame as alloc_rand(V), for n agents and m items.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Reductions","page":"Reference","title":"Reductions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Allocations]\nPages = [\"reductions.jl\"]","category":"page"},{"location":"reference/#Allocations.order-Tuple{Additive, Counts}","page":"Reference","title":"Allocations.order","text":"order(V::Additive, C::Counts)\n\nCreate an ordered instance for the given weights and categories. The items are reorded such that each category has a continous range of indices for its items. Returns a reduction, with a transformation that converts an allocation to one in the original instance where each agent gets at least the same value as in the ordered instance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.order-Tuple{Additive}","page":"Reference","title":"Allocations.order","text":"order(V::Additive)\n\nCreate an ordered instance for the given weights. The weights are reordered for each agent such that item 1 is worth the most and item m is worth the least. Returns new additive valuations and a function to convert an allocation in the ordered instance into one for the original instance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.reduce-Tuple{Additive, Counts{OrderedCategory}, Any, Any}","page":"Reference","title":"Allocations.reduce","text":"reduce(V::Additive, C::Counts{OrderedCategory}, i, B)\n\nReduce the instance given by the pair (V, C) to a new instance by giving the supplied agent, i, the supplied bundle, B. Returns a reduction, where the transformation, in addition to converting the allocation to one for the original instance, allocates B to i.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.reduce-Tuple{Additive, Counts{OrderedCategory}, Real}","page":"Reference","title":"Allocations.reduce","text":"reduce(V::Additive, C::Counts{OrderedCategory}, α)\n\nReduce an ordered instance by normalizing the values and giving any agent that value an individual item greater than or equal to α the item and any low value items required to reduce to a valid instance. This reduction is performed recursively until no more such items exist. The reduction does not decrease the MMS guarantee of any remaining agents and all agents that are allocated a bundle in the reduction is guaranteed to value their bundle at least α of their MMS guarantee.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.reduce-Tuple{Additive, Real}","page":"Reference","title":"Allocations.reduce","text":"reduce(V::Additive, α::Real; greedy::Bool=true)\n\nReduce an ordered instance by normalizing the values and giving any agent that value an individual item greater than or equal to α the item.  This reduction is performed recursively until no more such items exist. The reduction does not decrease the MMS guarantee of any remaining agents and all agents that are allocated a bundle in the reduction is guaranteed to value their bundle at least α of their MMS guarantee. The agent-item pairs are either selected greedily or by finding a maximum matching between agents and such items.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.reduce-Tuple{Additive, Vararg{Function}}","page":"Reference","title":"Allocations.reduce","text":"reduce(V::Additive, F::Function...)\n\nReduce an instance V by repeatedly applying the functions f ∈ F to find bundles to be allocated. The functions in F are expected to return either a pair, (i, B), consisting of an agent i and the bundle B to be assigned to agent i, or the value nothing if the function couldn't find a valid bundle-agent-pair. The functions are called in prioritized order and the instance is reduced and normalized between each invocation. The functions are invoked with the valuation matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.reduce-Tuple{Profile, Real}","page":"Reference","title":"Allocations.reduce","text":"reduce(V::Profile, α::Real)\n\nProduce a reduced instance by giving an item to any agent that values it at α or more. This reduction is performed repeatedly, until no such item exists.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.reduce-Tuple{Profile, Vararg{Pair}}","page":"Reference","title":"Allocations.reduce","text":"reduce(V::Valuation, assignment::Pair...)\n\nReduce the instance given to a new instance where the involved agents and bundles in the assignments are removed. Returns new valuations and a function that turns an allocation in the reduced instance into one for the original instance, including giving the supplied agent the supplied bundle.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.reduce-Tuple{Submodular, Any, Any}","page":"Reference","title":"Allocations.reduce","text":"reduce(V::Submodular, i, B)\n\nReduce the instance given by V to a new instance by giving the specified bundle, B, to agent i. Returns a reduction, where the transformation, in addition to converting the allocation to one for the original instance, allocates B to i.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.reduceutil-Tuple{Profile, Vararg{Pair}}","page":"Reference","title":"Allocations.reduceutil","text":"reduceutil(V::Profile, assignments::Pair...)\n\nUtility function that given valuations and a collection of assignments of bundles to agents (i => B), creates a reduced instance, translation tables from the reduced instance and a function to convert an allocation in the reduced instance to one in the original instance – including the given assignements. The function returns a Reduction object without any constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.reducevaluation-Tuple{Additive, Any, Any}","page":"Reference","title":"Allocations.reducevaluation","text":"reducevaluation(V::Additive, λi, λg)\n\nUtility function that given additive valuations prior to a reduction and translation tables for the reduction, returns new additive valuations for the reduced instance. The new valuations are as prior to the reduction, except for missing items/agents and changes in item/agent numbers.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.reducevaluation-Tuple{Submodular, Any, Any}","page":"Reference","title":"Allocations.reducevaluation","text":"reducevaluation(V::Submodular, λi, λg)\n\nUtility function that given submodular valuations prior to a reduction and translation tables for the reduction, returns new submodular valuations for the reduced instance. The new valuations are as prior to the reduction, except for missing items/agents and changes in item/agent numbers. That is, the new valuation functions work by translating the item numbers to what they would be prior to the reduction and calling the valuation function of the agent prior to the reduction.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.revert-NTuple{4, Any}","page":"Reference","title":"Allocations.revert","text":"revert(λi, λg, assignments, A)\n\nConvert an allocation for a reduced instance to one for the original instance, including giving the removed bundles to the removed agents.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.revert-Tuple{Additive, Any}","page":"Reference","title":"Allocations.revert","text":"revert(V::Additive, A)\n\nConvert an allocation for the ordered instance to one for the original instance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.revert-Tuple{Additive, Counts, Counts, Any}","page":"Reference","title":"Allocations.revert","text":"revert(V::Additive, C::Counts, C′::Counts, A)\n\nConvert an allocation for the ordered instance (C′) to one for the original instance (V, C).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MIP-based-allocation","page":"Reference","title":"MIP-based allocation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Allocations]\nPages = [\"mip.jl\"]","category":"page"},{"location":"reference/#Allocations.alloc_ef1-Tuple{Any, Any}","page":"Reference","title":"Allocations.alloc_ef1","text":"alloc_ef1(V, C; solver=conf.MIP_SOLVER, kwds...)\n\nCreate an Allocation that is envy-free up to one item (EF1), based on the valuation profile V, possibly subject to the constraints given by the Constraint object C. The solution is found using a straightforward mixed-integer program, and is most suitable for constraints where no specialized algorithm exists. For example, without constraints, a straightforward round robin picking sequence yields EF1, and a similar strategy works for cardinality constraints. (It is still possible to use this function without constraints, by explicitly supplying nothing for the constraint argument C.) The return value is a named tuple with the fields alloc (the Allocation) and model (the JuMP model used in the computation).\n\nLower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments min_bundle, max_bundle, min_owners and max_owners, the latter two of which default to 1. If one of these is nothing, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.\n\nNote that for some constraints, there may not be an EF1 allocation, in which case the function will fail with an exception.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.alloc_efx","page":"Reference","title":"Allocations.alloc_efx","text":"alloc_efx(V[, C]; solver=conf.MIP_SOLVER, kwds...)\n\nCreate an Allocation that is envy-free up to any item (EFX), based on the valuation profile V, possibly subject to the constraints given by the Constraint object C. The solution is found using a straightforward mixed-integer program. The return value is a named tuple with the fields alloc (the Allocation) and model (the JuMP model used in the computation).\n\nLower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments min_bundle, max_bundle, min_owners and max_owners, the latter two of which default to 1. If one of these is nothing, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.\n\nNote that while some constraints may prevent an exact EFX allocation, it is currently (Mar 2021) an open question whether EFX always exists in the unconstrained case (see, e.g., Improving EFX Guarantees through Rainbow Cycle Number by Chaudhury et al.).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.alloc_ggi","page":"Reference","title":"Allocations.alloc_ggi","text":"alloc_ggi(V[, C]; wt=wt_gini, solver=conf.MIP_SOLVER, kwds...)\n\nMaximizes a generalized Gini index (GGI), also known as a generalized Gini social-evaluation functions. The function being maximized is an ordered weighted average (OWA) of agent utilities, utilities, where the weight is based on utility rank i, from the least happy (1) to the most happy (n), parameterized by the function wt(i, n). It is generally assumed that the weights are nondecreasing in i. Note that there is no need to use normalized weights (i.e., to produce a weighted average, despite the term OWA), as is often the case when such measures are used to measure inequality (e.g., by subtracting the OWA from an ordinary average, cf. Generalized gini inequality indices by John A. Weymark).\n\nThe default wt_gini gives the (non-normalized) weights of the original Gini social-evaluation. Two other notable cases for wt are (i, _) -> i == 1, which yields a maximin allocation, and (i, _) -> 1, which yields a purely utilitarian allocation (with no consideration for fairness). The solution method used is based on that of Lesca and Perny (linear formulation Pi_W) in their paper 2010 paper “LP Solvable Models for Multiagent Fair Allocation Problems”. The return value is a named tuple with the fields alloc (the Allocation that has been produced) and model (the JuMP model used in the computation).\n\nLower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments min_bundle, max_bundle, min_owners and max_owners, the latter two of which default to 1. If one of these is nothing, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.\n\nIn the original inequality measures, the mean agent utility is included as a normalizing term, which is harmless for the case of identical valuations functions (and when looking at, say, the distribution of incomes), but when valuations differ, this mean will vary with the allocations. As pointed out by Lesca and Perny, such a measure is not monotone with Pareto dominance – the optimization will tend to drive the mean utility down. Therefore only the term measuring (in)equality (i.e., the ordered weighted sum of agent utilities) is used.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.alloc_mm","page":"Reference","title":"Allocations.alloc_mm","text":"alloc_mm(V[, C]; cutoff=nothing, solver=conf.MIP_SOLVER, kwds...)\n\nCreate an egalitarion or maximin Allocation, i.e., one where the minimum bundle value is maximized. The cutoff, if any, is a level at which we are satisfied, i.e., any allocation where all agents attain this value is acceptable. The return value is a named tuple with fields alloc (the Allocation), mm (the lowest agent utility) and model (the JuMP model used in the computation).\n\nLower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments min_bundle, max_bundle, min_owners and max_owners, the latter two of which default to 1. If one of these is nothing, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.alloc_mms","page":"Reference","title":"Allocations.alloc_mms","text":"alloc_mms(V[, C]; cutoff=false, solver=conf.MIP_SOLVER, kwds...)\n\nFind an MMS allocation, i.e., one that satisfies the maximin share guarantee, where each agent gets a bundle it weakly prefers to its maximin share (introduced by Budish, in his 2011 paper The Combinatorial Assignment Problem: Approximate Competitive Equilibrium from Equal Incomes). The return value is a named tuple with fields alloc (the Allocation), mmss, the individual MMS values for the instance, alpha, the lowest fraction of MMS that any agent achieves (is at least 1 exactly when the allocation is MMS), model (the JuMP model used in computing alpha) and mms_models (the JuMP models used to compute the individual maximin shares). If cutoff is set to true, this fraction is capped at 1.\n\nLower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments min_bundle, max_bundle, min_owners and max_owners, the latter two of which default to 1. If one of these is nothing, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.\n\nBecause of how they interact with the calculation of MMS, the agent-asymmetric limits min_bundle and max_bundle must be scalars (or, more generally, satisfy allequal).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.alloc_mnw","page":"Reference","title":"Allocations.alloc_mnw","text":"alloc_mnw(V[, C]; mnw_warn=false, solver=conf.MIP_SOLVER, kwds...)\n\nCreate an Allocation attaining maximum Nash welfare (MNW), based on the valuation profile V, possibly subject to the constraints given by the Constraint object C. The solution is found using the approach of Caragiannis et al. in their 2019 paper The Unreasonable Fairness of Maximum Nash Welfare, with two minor modifications:\n\nRather than hard-coding a maximum valuation (arising from the assumption that the values of each agent sum to 1000), this maximum is extracted from V; and\nExtra constraints are permitted (through the object C), possibly lowering the attainable MNW.\n\nBecause of how the integer program is constructed, it may be affected by precision effects, where a high number of agents can make it impossible to guarantee Pareto optimalty (PO), EF1 or MNW. If the precision is too low, the appropriate warning will be issued, but the computation is not halted. Note that these warnings are quite conservative (see note below). This is particularly true of the one for MNW, which is disabled by default, in part because of its sensitivity, and in part because it will generally be useful to find solutions that satisfy PO and EF1, even if it may not be exactly MNW. The MNW warning can be enabled by setting the mnw_warn keyword to true.\n\nnote: Note\nThe warnings are based on the lower bounds described by Caragiannis et al. On the one hand, the bound is only used to test whether current floating-point precision is sufficient; any tolerance or gap used by the solver is not used, which might in principle mean that false negative are possible. On the other hand, these bounds, especially the one for exact MNW, may in practice be quite loose, with small variations in agent utilities leading to large changes in objective value, unless the changes are finely tuned to cancel out.\n\nThe return value is a named tuple with fields alloc (the Allocation), mnw (the achieved Nash welfare for the agents with nonzero utility), mnw_prec (whether or not there was enough precision to satisfy the lower bound guaranteeing exact MNW) and model (the JuMP model used in the computation).\n\nLower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments min_bundle, max_bundle, min_owners and max_owners, the latter two of which default to 1. If one of these is nothing, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.alloc_mnw_ef1-Tuple{Any, Any}","page":"Reference","title":"Allocations.alloc_mnw_ef1","text":"alloc_mnw_ef1(V, C; mnw_warn=true, solver=conf.MIP_SOLVER, kwds...)\n\nEquivalent to alloc_mnw, except that EF1 is enforced. Without any added constraints, MNW implies EF1, so this function is not needed in that case. Therefore the argument C is not optional.\n\nLower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments min_bundle, max_bundle, min_owners and max_owners, the latter two of which default to 1. If one of these is nothing, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.mms","page":"Reference","title":"Allocations.mms","text":"mms(V, i[, C]; solver=conf.MIP_SOLVER, kwds...)\n\nDetermine the maximin share of agent i, i.e., the bundle value she is guaranteed to attain if she partitions the items and the other agents choose their bundles. Useful, e.g., as a point of reference when determining the empirical approximation ratios of approximate MMS allocation algorithms. Also used as a subroutine in alloc_mms. The return value is a named tuple with the fields mms (the maximin share of agent i) and model (the JuMP model used in the computation).\n\nLower and upper limits on the size of each bundle and the number of owners for each item may be supplied using the keyword arguments min_bundle, max_bundle, min_owners and max_owners, the latter two of which default to 1. If one of these is nothing, the limit is simply absent. Otherwise, the argument is broadcast to the appropriate size.\n\nBecause of how they interact with the calculation of MMS, the agent-asymmetric limits min_bundle and max_bundle must be scalars (or, more generally, satisfy allequal).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Allocations.mms_alpha-Tuple{Any, Any, Any}","page":"Reference","title":"Allocations.mms_alpha","text":"mms_alpha(V, A, mmss)\n\nUtility function to find the fraction of the maximin share guarantee attained by the allocation A, under the valuation profile V, where mmss[i] is the MMS of agent i. This makes it possible, for example, to use the mmss field from the result of alloc_mms to find the MMS approximation provided by an allocation constructed by other means. For example:\n\nmmss = alloc_mms(V).mmss\nA = alloc_rand(V).alloc\nalpha = mms_alpha(V, A, mmss)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Allocations.wt_gini-Tuple{Any, Any}","page":"Reference","title":"Allocations.wt_gini","text":"wt_gini(i, n)\n\nThe (unnormalized) weights used in the ordered weighted average in the Gini social-evaluation function, where the utility of the ith agent, ordered by increasing utility, is given weight 2(n - i) + 1. (The normalized weights yielding the original Gini social-evaluation function are divided by n^2, but this makes no difference to the optimization problem.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Configuration","page":"Reference","title":"Configuration","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Allocations]\nPages = [\"conf.jl\"]","category":"page"},{"location":"reference/#Allocations.conf","page":"Reference","title":"Allocations.conf","text":"conf\n\nA struct with fields for global configuration of the Allocations module.\n\nFields\n\nMIP_SOLVER::Any\n\nThe (factory for the) JuMP optimizer to be used (by default) for mixed-integer programming. Initially set to HiGHS.Optimizer, with log_to_console set to false. This can be overridden either by setting MIP_SOLVER to another value (e.g., using the JuMP function optimizer_with_attributes) or by passing the solver directly to the appropriate allocation functions.\n\nMIP_SUCCESS::Any\n\nContainer of acceptable MIP statuses. By default, has the value [MOI.OPTIMAL].\n\n\n\n\n\n","category":"constant"},{"location":"#Allocations.jl","page":"Allocations.jl","title":"Allocations.jl","text":"","category":"section"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"The Allocations package deals with the fair allocation of indivisible items to a set of agents. An instance of this problem consists of:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"A set N of n agents and a set M of m items;\nOne valuation function v_i2^MtoR for each agent iin N;","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"For simplicity, we may simply let N=1dotsn and M=1dotsm.[1]","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"The goal is to find an allocation A=(A_1dotsA_n), which gives a bundle A_isubseteq M to each agent, and which satisfies certain fairness criteria. The allocation is usually required to form a partition of M, though in some scenarios, one may deviate from this.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"In Allocations.jl, an instance is represented by the valuation profile V=v_iiin N, in the form of a Profile object. Given a profile V, the various parts of the instance may be accessed as follows:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"items(V): The item set N, as an iterable;\nagents(V): The agent set M, as an iterable;\nvalue(V, i, S): The value agent i assigns to the set Ssubseteq M, i.e., v_i(S).","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"S may be any iterable. If it a single item (i.e., Int) g, it is interpreted as a singleton, [g] (though usually handled more efficiently). The number of agents and items, respectively, is found using na(V) and ni(V)","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"In addition to this basic setting, instances may be constrained, by supplying some constraint object, describing which bundles are feasible. For example, if one is looking for bundles that are connected in some sense, the constraint object will typically be a graph that defines the connectivity relation, etc.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Allocations are represented by Allocation objects. Given an allocation A, the bundle of agent i is found using bundle(A, i).","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"tip: Tip\nFor more on this topic, see, e.g., the Wikipedia entry on fair item allocation, or the surveys by Amanatidis et al. and Suksompong, on the unconstrained and constrained versions of the problem, respectively.","category":"page"},{"location":"#Installation","page":"Allocations.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"To install the package, you can simply import it in the Julia REPL:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"julia> using Allocations","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Press enter at the resulting prompt to install both the package and its dependencies.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"To install a more recent version than the released one, you can use the package manager directly. In the Julia REPL, press ] to enter the Pkg REPL, and then add the package directly from the source:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"pkg> add https://github.com/mlhetland/Allocations.jl","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"You can then import the module as before.","category":"page"},{"location":"#Basic-use","page":"Allocations.jl","title":"Basic use","text":"","category":"section"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"To specify an allocation problem instance, create a valuation profile:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"julia> V = Profile([1 2 3; 2 3 1])\nAdditive{Matrix{Int64}} with 2 agents and 3 items:\n 1  2  3\n 2  3  1","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Profile is an abstract class, and Profile(X::Matrix) is an alias for Additive(X). Once you have a valuation profile, you can use an allocation function (ones called alloc_...), e.g., for finding a maximum Nash welfare (MNW) allocation:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"julia> res = alloc_mnw(V);","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Note that the first time you call an allocation function, it may take some time to finish, because there's quite a lot of compilation going on behind the scenes. From then on, in the same REPL session, there will be much less overhead.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"These functions take a Profile as input and return a named tuple with the field alloc referring to an Allocation:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"julia> A = res.alloc\nAllocation with 2 agents and 3 items:\n  1 => {3}\n  2 => {1, 2}","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"The bundles of each agent is available through the bundle function:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"julia> bundle(A, 2)\nSet{Int64} with 2 elements:\n  2\n  1","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Bundles should not be modified directly, as the Allocation also maintains an inverse mapping, from items to agents. Rather, use the give! and deny! functions.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Some allocation functions may produce other results as well, such as properties of the allocation that are naturally computed as part of the allocation process. For the MNW case, the objective value (the Nash welfare, which is being maximized) is available as mnw:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"julia> res.mnw\n15.0","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"The allocation functions also permit a matrix argument as a shortcut, implicitly creating an Additive. For example, you can find a maximin share (MMS) allocation as follows:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"julia> alloc_mms([1 1 2 3; 2 1 2 3]).alloc\nAllocation with 2 agents and 4 items:\n  1 => {2, 3}\n  2 => {1, 4}","category":"page"},{"location":"#Solver-configuration","page":"Allocations.jl","title":"Solver configuration","text":"","category":"section"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Several allocation functions use mixed-integer linear programming via JuMP. Depending on the choice of MIP solver, solving even moderately-sized instances may take a significant amount of time. Choosing a different solver (from the default HiGHS.Optimizer) may speed things up considerably. For example, with the appropriate license, one could use use Gurobi as follows:[2]","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Allocations.conf.MIP_SOLVER = Gurobi.Optimizer","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"It is also possible to supply the Optimizer (or other optimizer factories, e.g., constructed using optimizer_with_attributes) as the solver keyword argument to the relevant allocation functions.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Normally, the MIP solvers will print out quite a lot of information about what they're doing. If you're not interested in this output, you can generally turn it off using some solver-specific flag, supplied to optimizer_with_attributes.[3] This is also where you'd supply other parameters, e.g., indicating time limits, acceptable inaccuracies, etc. For example:[4]","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"Allocations.conf.MIP_SOLVER = optimizer_with_attributes(\n    Gurobi.Optimizer,\n    \"LogToConsole\" => 0,     # No console output\n    \"TimeLimit\" => 60,       # Finish within 60 seconds\n    \"MipGap\" => 0.05,        # Permit 5% suboptimality\n)","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"If you're unable to get rid of the output using solver parameters, a simple solution is to just silence all output while allocating:","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"julia> redirect_stdout(devnull) do\n           alloc_mnw(V)\n       end","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"If that doesn't do the trick, you could add redirect_stderr as well.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"[1]: The latter is less common, presumably because the two sets then intersect. An alternative is to let M be a set of opaque objects g_j, for j=1dots m.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"[2]: If you're a student or a researcher, Gurobi is available for free under an academic license.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"[3]: There is also the JuMP.set_silent function, but it requires access to the MIP model.","category":"page"},{"location":"","page":"Allocations.jl","title":"Allocations.jl","text":"[4]: See the Gurobi manual for explanations.","category":"page"}]
}
